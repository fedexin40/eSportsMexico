<?php
// Define los estados del desafío
	define( 'CREADO', 0 );
	define( 'PROGRAMADO', 1 );
	define( 'CANCELADO', 2 );
	define( 'COMPLETADO', 3 );
	define( 'CONFLICTO', 4 );
	define( 'ELIMINADO', 5 );
	define( 'TABLERO', 6 );
    
//Defnie los tipos de reto que puede haber
  define ('DESAFIO', 0);
  define ('IS_TORNEO', 1);
  
//Defnie los estados de reporte de resultados
  define ('INCOMPLETO', 0);
  define ('VICTORIA', 1);
  define ('DERROTA', 2);
  define ('PROTESTA', 3);
	
/**	DONE
 * Implementation of hook_node_info()
 * Declare the content type match
 * 
 */ 
function match_node_info() {
	return array (
		'match' => array (
			'name' => t('Desafio'),
			'module' => 'match',
			'description' => t("Un partido entre dos equipos inscritos en el ranking."),
		)
	);
}
/**	DONE
* Implementation of hook_perm()
* Outlines permissions for this module.
* @return array - An array of valid permissions for the match module
*/
function match_perm( ){
    return array( 'administer matches', 'create match', 'edit own match', 'delete own match', 'enter results');
}//end function match_perm()

/** DONE
 * Implementation of hook_access()
 */
function match_access($op, $node, $account){
    //users who can administer matches can do anything.
    if ( user_access('adminster matches', $account ) )
        return TRUE;
    
    if ($op == 'create') {
        // Only users with permission to do so may create this node type.
        return user_access('create match', $account);
    }
    
    if ($op == 'update') {
        if (user_access('edit own match', $account) && ($account->uid == $node->uid)) {
            return TRUE;
        }
    }
    
    if ($op == 'delete') {
        if(user_access('delete own match', $account) && ($account -> uid == $node ->uid)) {
            return TRUE;
        }
    }
    
    if ($op == 'view') {
        if(user_access('access content', $account)) {
            return TRUE;
        }
    }
    return FALSE;
}
	
	
	
/**
 *	Implememtation of hook_form( )
 *	Sets up the form to submit matches
 *	Permite tomar algunos argumentos de la barra de dirección para
 *	definir los partidos dentro de un torneo, o desafío específico
 *	@param
 *	  arg(3) = id_Modalidad_Juego_Temporada
 *	  arg(4) = nid_Equipo_Visitante
 */
function match_form( &$node, $form_state ) {
	$format = 'Y-m-d H:i';
  global $user;
	$tid = arg(2);
	$modalidad = term_is_active($tid);
   
  if($node->Fecha_Inicio != '')
    $start_hour = format_date($node->Fecha_Inicio, 'custom', $format);
  else
    $start_hour = format_date(time(), 'custom', $format);
  
	//Verifica el estado del desafío y si es posible editarlo 
  if (isset($node->Estado) && !(($node->Estado == CREADO) || ($node->Estado == TABLERO)))
		//El partido ya está en estado de programado o posterior y no se pueden editar las opciones
    $mensaje = t('No se pueden editar las opciones de este partido.');

	if (!isset($node->id_Modalidad_Juego_Temporada) && is_object($modalidad))
		$node->id_Modalidad_Juego_Temporada = $modalidad->id_Modalidad_Juego_Temporada;
	elseif (!(is_object($modalidad)))
		$mensaje = t('No se ha asignado una modalidad a este desafio.');
    
	if (!isset($node->Estado))
		$node->Estado = CREADO;
		
  //Obtenemos los datos del equipo visitante
	if (is_numeric(arg(4)))
		$node->away_team = arg(4);
	if (!is_null ($node->nid_Equipo_Visitante))
		$node->away_team = $node->nid_Equipo_Visitante;
	
	if (!is_null($node->away_team))
		$away_team = node_load(array('nid' => $node->away_team));
	elseif ($node->Estado != TABLERO)
		$mensaje = t('No se ha seleccionado ningun equipo a desafiar.');
	
	//Obtenemos los datos del equipo local
	$Equipo_Local = is_capitan($user->uid, $node->id_Modalidad_Juego_Temporada);
	if (is_null($Equipo_Local)) {
		if (($modalidad->Minimo_Jugadores > 1) && (tiene_equipo($user->uid, $node->id_Modalidad_Juego_Temporada) == TIENE_EQUIPO))
			$mensaje = t('Solo los capitanes de equipo pueden crear desafios.');
		else
			$mensaje = t('Necesitas inscribirte al ránking para poder empezar a desafiar.<br/>Para inscribirte al ranking haz click en este link: '. l('Click', 'taxonomy/term/'. $modalidad->tid));
	}	
	$node->home_team = $Equipo_Local->nid;
		
	//Determina que se tiene que desplegar en la forma
	if ($mensaje) {
		$form['mensaje'] = array(
			'#value' => $mensaje,
			'#weight' => -100,
		);
	}
	else {
		$form['id_Modalidad_Juego_Temporada'] = array(
			'#type' => 'hidden',
			'#value' => $node->id_Modalidad_Juego_Temporada,
		);
		
		$form['Estado'] = array(
			'#type' => 'hidden',
			'#value' => $node->Estado,
		);
		$form['Tipo'] = array(
			'#type' => 'hidden',
			'#value' => $node->Tipo,
		);
		
		$form['home_team'] = array(
			'#type' => 'hidden',
			'#value' => $node->home_team,
		);
		
		$form['Numero_Rondas'] = array(
			'#type' => 'select',
			'#title' => t('Numero de Rondas'),
			'#required' => TRUE,
			'#options' => array (
											1 => '1',
											2 => '2',
											3 => '3',
											4 => '4',
											5 => '5',
													 ),
			'#weight' => -9,
			'#default_value' => $node->Numero_Rondas,
		);

		if (!is_null($node->away_team)) {
			$form['away_team'] = array(
				'#value' => $node->away_team,
				'#type' => 'hidden'
			);
			$form['body_filter']['body'] = array(
				'#type' => 'textarea',
				'#title' => t('Match Notes'),
				'#default_value' => $node->body,
				'#required' => FALSE,
				'#description' => t('Use this to enter some pre-match comments for the game.'),
				'#weight' => -90,
			);
		}
		else {
			drupal_set_title(t("Add match to match's board."));
			
			$form['mensaje'] = array(
				'#value' => t('Envía tu desafío indicando la fecha y hora a la que prefieres jugar. También debes seleccionar las preferencias de juego para el enfrentamiento. Ten en cuenta que si tu rival acepta el desafío, ya no podrá ser cancelado. Asegúrate de estar disponible en el momento que indicas o sufrirás una derrota por incomparecencia.'),
				'#weight' => -100,
			);
		}
		
		$form[ 'Fecha' ] = array (
			'#type' => 'date_select', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
			'#title' => 'Fecha y Hora de Inicio del Match',
			'#default_value' => $start_hour, 
			'#date_format' => $format,
			'#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
			'#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
			'#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
			'#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
			'#weight' => -80,
		);
		$form['body_filter']['filter'] = filter_form($node->format);
	}
	
	return $form;
}
/*
 * Implementation of hook_load()
 * Esta función obtiene la información adicional almancenada en la base de datos de eSM
 * y la agrega al objeto de tipo nodo para su reproducción o manejo
 */
function match_load( $node ) {
  db_set_active('eSM');
	$reto = db_fetch_object(db_query( 'SELECT { * } FROM { Reto } AS { r } INNER JOIN { Inicio_Reto } AS { ir } ON { r.nid_Reto = ir.nid_Reto } WHERE { r.nid_Reto = %d }', $node->nid ) );
  db_set_active('default');

  $node->Estado = $reto->Estado;
  $node->id_Modalidad_Juego_Temporada = $reto->id_Modalidad_Juego_Temporada;
  $node->Fecha_Inicio = $reto->Fecha_Inicio;
  $node->Numero_Rondas = $reto->Numero_Rondas;
  $node->Tipo = $reto->Tipo;
  $node->nid_Equipo_Local = $reto->nid_Equipo_Local;
  $node->nid_Equipo_Visitante = $reto->nid_Equipo_Visitante;
  $node->Puntuacion_Inicial_Equipo_Local = $reto->Puntuacion_Inicial_Equipo_Local;
  $node->Puntuacion_Inicial_Equipo_Visitante = $reto->Puntuacion_Inicial_Equipo_Visitante;

  if ($reto->Estado == COMPLETADO) {    //Si el estado del reto es completado entonces carga los datos adicionales de la tabla de Final_Reto
    db_set_active('eSM');
      $resultado = db_fetch_object(db_query('SELECT * FROM {Fin_Reto} WHERE nid_Reto = %d', $node->nid));
    db_set_active('default');
    
    $node->ganador = $resultado->nid_Equipo_Ganador;
    $node->Puntuacion_Final_Equipo_Local = $resultado->Puntuacion_Final_Equipo_Local;
    $node->Puntuacion_Final_Equipo_Visitante = $resultado->Puntuacion_Final_Equipo_Visitante;
  }
  elseif ($reto->Estado == CONFLICTO) {
    db_set_active('eSM');
      $pruebas = db_fetch_object(db_query('SELECT * FROM {Prueba} WHERE nid_Reto = %d', $node->nid));
    db_set_active('default');
    
    $node->Prueba_Local = $pruebas->Prueba_Jugador_Local;
    $node->Prueba_Visitante = $pruebas->Prueba_Jugador_Visitante;
  }
  
  //load additional match data 
  module_invoke_all('match_load', $node);

  return $node;
}

/**	DONE
 * Implementation of hook_validate
 * Validates the match type before submission to ensure that the setup is correct
 * @param Object $node
 * @param Array $form
 */
function match_validate($node, $form){
  //Revisa que el partido tenga una temporada válida
  if (!isset($node->id_Modalidad_Juego_Temporada))
    form_set_error($node->id_Modalidad_Juego_Temporada, t('No has seleccionado una temporada validad para el partido.'));
  
  //Check that a team is not playing itself
  if( $node->home_team == $node->away_team ) {
    form_set_error( $node->away_team, t('A team cannot play itself!'));
  }
  
  //Checa que exista un equipo al que se está retando
  if ($node->away_team == 0)
    form_set_error( $node->away_team, t('No se ha seleccionado uno de los equipos'));
    
  //Checa que los equipos tengan el mínimo de jugadores necesarios para la modalidad
  $modalidad = get_modalidad($node->id_Modalidad_Juego_Temporada);
  $local = node_load(array('nid' => $node->home_team));
  $visitante = node_load(array('nid' => $node->away_team));
  if ($local->Numero_Integrantes < $modalidad->Minimo_Jugadores)
    form_set_error( $node->home_team, t('El equipo '. $local->title .' no tiene el minimo de jugadores necesarios.'));
  if ($visitante->Numero_Integrantes < $modalidad->Minimo_Jugadores)
    form_set_error( $node->away_team, t('El equipo '. $visitante->title .' no tiene el minimo de jugadores necesarios.'));
	
  //Revisa que estén configurados los modos de juego de la modalidad o muestra un mensaje de error correspondiente
  $modos = modos_get_modos_modalidad($modalidad->id_Modalidad_Juego);
  if (!is_array($modos))
    form_set_error($node->id_Modalidad_Juego_Temporada, t('Las reglas para esta modalidad no estan correctamente definidas.<br/>Por favor contacta a un administrador'));
    
  //Revisa que los desafíos estén programados con un mínimo de 10min de anticipació y un máximo de 15 días
  $fecha_incio = strtotime($node->Fecha);     //Obtiene la fecha de inicio en formato timestamp
  
  if ($fecha_incio < (time() + 10*60) || $fecha_incio > (time() + 15*24*60*60))
    form_set_error($node->Fecha, t('La fecha de un desafio no se puede programar con menos de 10 minutos de anticipacion ni con más de 15 días de anticipacion.'));
  
  //Revisa que los equipos no tengan desafíos programados 60 minutos antes o después del inicio de este desafío
  db_set_active('eSM');
    $partidos_local = db_result(db_query('SELECT COUNT(*) FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ie ON r.nid_Reto = ie.nid_Reto WHERE
                               (nid_Equipo_Local = %d OR nid_Equipo_Visitante = %d)
                               AND (Fecha_Inicio > %d AND Fecha_Inicio < %d)
                               AND (Estado = %d)',
                               $node->home_team, $node->home_team, ($fecha_incio - 60*60), ($fecha_incio + 60*60), PROGRAMADO));
    $partidos_visitante = db_result(db_query('SELECT COUNT(*) FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ie ON r.nid_Reto = ie.nid_Reto WHERE
                                   (nid_Equipo_Local = %d OR nid_Equipo_Visitante = %d)
                                   AND (Fecha_Inicio > %d AND Fecha_Inicio < %d)
                                   AND (Estado = %d)',
                                   $node->away_team, $node->away_team, ($fecha_incio - 60*60), ($fecha_incio + 60*60), PROGRAMADO));
  db_set_active('default');
  
  if ($partidos_local > 0) {
    form_set_error($node->home_Team, t('El equipo '. $local->title .' tiene un desafio programado que entra en conflicto con este desafio.'));
  }
  if ($partidos_visitante > 0) {
    form_set_error($node->away_team, t('El equipo '. $visitante->title .' tiene un desafio programado que entra en conflicto con este desafio.'));
  }
  
  //Revisa que los equipos no tengan 3 desafíos en estado de conflicto
  db_set_active('eSM');
    $conflictos_local = db_result(db_query('SELECT COUNT(*) FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ir ON r.nid_Reto = ir.nid_Reto WHERE
                                 (nid_Equipo_Local = %d OR nid_Equipo_Visitante = %d) AND Estado = %d',
                                 $node->home_team, $node->home_team, CONFLICTO));
    $conflictos_visitante = db_result(db_query('SELECT COUNT(*) FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ir ON r.nid_Reto = ir.nid_Reto WHERE
                                     (nid_Equipo_Local = %d OR nid_Equipo_Visitante = %d) AND Estado = %d',
                                     $node->away_team, $node->away_team, CONFLICTO));
  db_set_active('default');
  
  if ($conflictos_local >= 3) {
    form_set_error($node->home_team, t('El equipo '. $local->title .' ha acumulado demasiados desafios en conflicto y no puede aceptar mas desafios.'));
  }
  if ($conflictos_visitante >= 3) {
    form_set_error($node->away_team, t('El equipo '. $visitante->title .' ha acumulado demasiados desafios en conflicto y no puede aceptar mas desafios.'));
  }
  
  //Revisa que los equipos no estén bloqueados por la liga
  $local = node_load(array('nid' => $node->home_team));
  if ($local->estado == BLOQUEADO)
    form_set_error($node->home_team, t('El equipo '. $local->title .' esta bloqueado y no puede aceptar mas desafios.'));
  $visitante = node_load(array('nid' => $node->away_team));
  if ($visitante->estado == BLOQUEADO)
    form_set_error($node->away_team, t('El equipo '. $visitante->title .' esta bloqueado y no puede aceptar mas desafios.'));
  
  //TODO: No se pueden disputar desafíos entre jugadores o equipos de diferentes divisiones (excepto durante el periodo de inicio de una temporada).
}
/**	
 * Implementation of hook_submit
 * Alters the title of the node before submission - otherwise it would be blank
 * @param Object $node
 */
function match_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL){
  if($op == 'presave' && $node->type == 'match'){
  //get the title. query the database to get the title of the teams.    
    $team = db_fetch_array(db_query("SELECT title FROM {node} WHERE nid = %d;", $node->home_team));
    $home_team = $team['title'];
    $team = db_fetch_array(db_query("SELECT title FROM {node} WHERE nid = %d;", $node ->away_team));
    $away_team = $team['title'];
    
    $search = array('[home_team]', '[away_team]');
    $replace = array($home_team, $away_team);

    $title = str_replace($search, $replace, '[home_team] vs [away_team]');
    
    $node->title = $title;
  }
}
/** DONE
 * Implementation of hook_insert()
 */
function match_insert($node){
  $fecha_inicio = strtotime($node->Fecha);
  //add the extra details to database
  db_set_active( 'eSM' );
    db_query( "INSERT INTO { Reto } ( nid_Reto, id_Modalidad_Juego_Temporada, Numero_Rondas, Fecha_Inicio, Tipo, Estado )
             VALUES (%d, %d, %d, %d, %d, %d )",
            $node->nid, $node->id_Modalidad_Juego_Temporada, $node->Numero_Rondas, $fecha_inicio, $node->Tipo, $node->Estado);
  
    $puntuacion_local = db_fetch_object(db_query('SELECT Puntuacion FROM {Puntuacion} WHERE nid_Equipo = %d', $node->home_team));
    $puntuacion_visitante = db_fetch_object(db_query('SELECT Puntuacion FROM {Puntuacion} WHERE nid_Equipo = %d', $node->away_team));
    
    db_query('INSERT INTO {Inicio_Reto} (nid_Reto, nid_Equipo_Local, nid_Equipo_Visitante, Puntuacion_Inicial_Equipo_Local, Puntuacion_Inicial_Equipo_Visitante)
             VALUES (%d, %d, %d, %d, %d)',
             $node->nid, $node->home_team, $node->away_team, $puntuacion_local->Puntuacion, $puntuacion_visitante->Puntuacion);
  
  db_set_active( 'default' );
  
  //TODO: use this hook
  module_invoke_all( 'match_insert', $node );
  
  //Asigna un conjunto de reglas para el match
  _match_asignar_reglas($node->nid, $node->Numero_Rondas);
  
  //Esta parte de la función notifica a los capitanes que les corresponde del desafío que se ha creado
  
  //Primero obtenemos los datos de los capitanes de los equipos  
    $home_team = node_load(array('nid' => $node->home_team));
    $away_team = node_load(array('nid' => $node->away_team));
    
    $home_capitan = user_load(array('uid' => $home_team->uid));
    $away_capitan = user_load(array('uid' => $away_team->uid));
        
  switch ($node->Estado) {
    case CREADO:        //Notifica al capitán del equipo visitante que el capitán del equipo local ha lanzado un reto contra él
        rules_invoke_event('desafio_lanzado', $home_capitan, $away_capitan, $node);
        
        break;
    
    case PROGRAMADO:    //Notifica a los capitanes de los dos equipos que se ha programado un partido entre ellos.
        $userB = user_load(array('uid' => 1));
        
        rules_invoke_event('partido_programado', $home_capitan, $away_capitan, $node);
        rules_invoke_event('partido_programado', $away_capitan, $home_capitan, $node);
        break;
  }
}

/**	DONE
 * Implementation of hook_update()
 * @param Object $node
 */
function match_update($node){
  //update the extra details to database
    $fecha_inicio = strtotime($node->Fecha);
  db_set_active( 'eSM' );
    db_query( "UPDATE { Reto } SET Numero_Rondas = %d, Fecha_Inicio = %d, Tipo = %d, Estado = %d
             WHERE nid_Reto = %d",
            $node->Numero_Rondas, $fecha_inicio, $node->Tipo, $node->Estado, $node->nid);
  db_set_active( 'default' );
  
  //TODO: use this hook
  module_invoke_all( 'match_insert', $node );
  
  //Esta parte de la función notifica a los capitanes que les corresponde del desafío que se ha creado
  
  //Primero obtenemos los datos de los capitanes de los equipos  
    $home_team = node_load(array('nid' => $node->home_team));
    $away_team = node_load(array('nid' => $node->away_team));
    
    $home_capitan = user_load(array('uid' => $home_team->uid));
    $away_capitan = user_load(array('uid' => $away_team->uid));
    
    rules_invoke_event('desafio_actualizado', $home_capitan, $away_capitan, $node);
    
  //call event_manager hook for an updated game
  module_invoke_all( 'match_update', $node );
}

/**	DONE
 *	Implementation of hook_delete()
 * @param Object $node
 */
function match_delete($node){
  //delete the extra details
	
  db_set_active( 'eSM' );
    $Reto = db_fetch_object( db_query( "SELECT * FROM { Reto } AS { r } WHERE { r.nid_Reto } = %d ", $node->nid ) );
  db_set_active( 'default' );
  
  db_set_active( 'eSM' );
    db_query("DELETE FROM { Reto } WHERE nid_Reto = %d", $node->nid );
    db_query('DELETE FROM {Inicio_Reto} WHERE nid_Reto = %d', $node->nid);
    db_query('DELETE FROM {Fin_Reto} WHERE nid_Reto = %d', $node->nid);
  db_set_active( 'default' );
  
  if ($Reto->Tipo == IS_TORNEO) {
    db_set_active('eSM');
	db_query('DELETE FROM {Retos_Torneos} WHERE nid_Reto = %d', $node->nid);
    db_set_active('default');
    
    watchdog('error', t('Se ha borrado un desafio programado dentro de un torneo.')); 
  }
  else {
    //Si es un reto completado actualizamos la tabla para restaurar los puntos como si el reto no hubiera existido.
    if( $Reto->Estado == 3 ) {
      //TODO: Actualizar el ránking del jugador haciendo la resta algebraica de puntos en su Puntuacion
      
    }
  }
  
  module_invoke_all( 'match_delete', $node );
}

/**	DONE
 * Implementation of hook_view()
 * @param $node
 * @param $teaser
 * @param $page
 * @return unknown_type
 */
function match_view($node, $teaser = FALSE, $page = FALSE){
	if ($node->Estado == TABLERO)
		$content = theme('match_board', $node);
  else
		$content = theme('match_content', $node);

  $node->content[] = array(
    '#value' => $content, 
    '#weight' => '0',
  );

  return $node;
}
/**	DONE
 * Implementation of hook_menu()
 * Sets up the admin menu system for the matches.
 */
function match_menu(){
  //Rutas para la sección de desafíos de cada modalidad
  $items[ 'taxonomy/term/%/match' ] = array (
    'title' => t('Desafios'),
    'page callback' => 'tablero_desafios',
    'access callback' => 'modalidad_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/match_tablero.inc',
		'weight' => 0
  );
  $items[ 'taxonomy/term/%/match/board' ] = array (
    'title' => t('Tablero'),
    'access callback' => 'modalidad_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_DEFAULT_LOCAL_TASK,
		'weight' => -100,
  );
  $items[ 'taxonomy/term/%/match/scheduled' ] = array (
    'title' => t('Proximos'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'modalidad_lista_desafios' ),
    'access callback' => 'modalidad_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/modalidad_lista_desafios.inc',
  );
  $items [ 'taxonomy/term/%/match/results' ] = array (
    'title' => t('Ultimos'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'modalidad_lista_desafios' ),
    'access callback' => 'modalidad_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/modalidad_lista_desafios.inc',
  );
  $items [ 'taxonomy/term/%/match/conflict' ] = array (
    'title' => t('Conflicto'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'modalidad_lista_desafios' ),
    'access arguments' => array('administer matches'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/modalidad_lista_desafios.inc',
		'weight' => 100,
  );
	
	//Formulario para colgar un reto en el tablero
  $items[ 'taxonomy/term/%/match/defy' ] = array (
    'title' => t('Add match'),
    'page callback' => 'tablero_new_match',
		'access arguments' => array('create match'),
    'type' => MENU_CALLBACK,
    'file' => 'inc/match_tablero.inc',
  );
	//Formulario para retar a un equipo
  $items[ 'taxonomy/term/%/defy/%' ] = array (
    'title' => t('Add match'),
    'page callback' => 'add_new_match',
		'access arguments' => array('create match'),
    'type' => MENU_CALLBACK,
    'file' => 'inc/match_defy.inc',
  );
	
  //Rutas para operaciones sobre desafíos
  $items['node/%node/accept'] = array(
    'title' => t('Aceptar Desafio'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_aceptar'),
    'access callback' => 'match_aceptar_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
    'file' => 'inc/match_aceptar.inc',
  );
  $items['node/%node/report'] = array(
    'title' => 'Result',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_report'),
    'access callback' => 'match_report_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
    'file' => 'inc/match_reportar.inc',
  );
  $items['node/%node/proof'] = array(
    'title' => 'Envio de Pruebas',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_pruebas'),
    'access callback' => 'match_report_access',
    'access arguments' => array('administer matches'),
    'type' => MENU_CALLBACK,
    'file' => 'inc/match_pruebas.inc',
  );

  //Rutas para detalles de desafíos de cada equipo
  $items[ 'node/%node/desafios' ] = array (
    'title' => t('Desafios'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'team_lista_desafios' ),
    'access callback' => 'match_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/match_lista_desafios.inc',
  );
  $items[ 'node/%node/desafios/programados' ] = array (
    'title' => t('Desafios Programados'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'team_lista_desafios' ),
    'access callback' => 'match_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'inc/match_lista_desafios.inc',
    'weight' => 0,
  );
  $items[ 'node/%node/desafios/confirmar' ] = array (
    'title' => t('Desafios por Confirmar'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'team_lista_desafios' ),
    'access callback' => 'match_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/match_lista_desafios.inc',
    'weight' => 1,
  );
  $items[ 'node/%node/desafios/conflicto' ] = array (
    'title' => t('Desafios en Conflicto'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'team_lista_desafios' ),
    'access callback' => 'match_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/match_lista_desafios.inc',
    'weight' => 2,
  );
  $items[ 'node/%node/desafios/terminados' ] = array (
    'title' => t('Desafios Terminados'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'team_lista_desafios' ),
    'access callback' => 'match_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/match_lista_desafios.inc',
    'weight' => 3,
  );
	
  return $items;
}

/**	DONE
 *	Access argument for the node report score page -
 *	just return node access for users who have permission to report the match score
 */
function match_report_access( $node ) {  
  global $user;
  
  //Revisa que el nodo sea del tipo match, en caso contrario devuelve falso
  if ($node->type != 'match')
    return FALSE;
  
  //users who can administer matches can do anything.
  if ( user_access( 'administer matches'))
    return TRUE;
  
  //Revisa que el usuario sea el capitán/creador de alguno de los dos equipos en el match
  if (team_user_is_team_capitan($user->uid, $node->nid_Equipo_Local) || team_user_is_team_capitan($user->uid, $node->nid_Equipo_Visitante))
    return TRUE;
  else
    return FALSE;
}
/**	DONE
 *	Access argument for the node report score page -
 *	just return node access for users who have permission to report the match score
 */
function match_aceptar_access( $node ) {
  global $user;

  //Revisa que el nodo sea del tipo match, en caso contrario devuelve falso
  if ($node->type != 'match')
    return FALSE;
  
  //Revisa que el usuario sea el capitán/creador del equipo retado
  if ( team_user_is_team_capitan($user->uid, $node->nid_Equipo_Visitante))
    return TRUE;
  else
    return FALSE;
}

/**
 * Función para verificar quien tiene acceso a la lista de desafios de un equipo
 */
function match_ver_lista_desafios_access($node) {
  global $user;
  
  //Revisa que el nodo sea del tipo match, en caso contrario devuelve falso
  if ($node->type != 'team')
    return FALSE;
  
  return user_access('access content', $user);
}
/**
 * Función para verificar quien tiene acceso a la lista de desafios de una modalidad
 */
function modalidad_ver_lista_desafios_access($node) {
  global $user;
  
  return user_access('access content', $user);
}
/** DONE
 * Implementation of hook_form_FORM_ID_alter
 * This sets the default team correctly on the dropdown boxes on the generated form
 */
function match_form_match_node_form_alter( &$form, $form_state ) {
    
}

/**	DONE
 * Implementation of hook_theme()
 * 
 */
function match_theme($existing, $type, $theme, $path) {
  return array(
    'match_content' => array(
      'file' => 'node_content.inc',
      'path' => drupal_get_path('module', 'match') .'/theme',
      'arguments' => array('node'),
    ),
    'match_board' => array(
      'file' => 'node_board.inc',
      'path' => drupal_get_path('module', 'match') .'/theme',
      'arguments' => array('node'),
    ),
    'match_fivestar_static' => array(
      'file' => 'fivestar.inc',
      'path' => drupal_get_path('module', 'match') .'/theme',
      'arguments' => array('rating' => NULL, 'stars' => 5),
    ),
    'match_lista_desafios' => array(
      'file' => 'lista_desafios.inc',
      'path' => drupal_get_path('module', 'match') .'/theme',
      'arguments' => array('form' => NULL),
    ),
    'match_lista_desafios_modalidad' => array(
      'file' => 'lista_desafios_modalidad.inc',
      'path' => drupal_get_path('module', 'match') .'/theme',
      'arguments' => array('form' => NULL),
    ),
  );
}
/**
 * Implementation of hook_cron().
 *
 * Revisar que partidos llevan más de 3 horas de la fecha programada y todavía no se han reportado resultados
 */
function match_cron() {
  module_load_include('inc', 'match', 'inc/cron');
  _match_cron_task();
}
/**
 * Implementation of hook_rules_event_info().
 * Usado para notificar a los capitanes de los desafíos lanzados, aceptados, cancelados y programados
 * @ingroup rules
 */
function match_rules_event_info() {
  return array(
    'desafio_lanzado' => array(
      'label' => t('UserA ha desafiado al equipo de userB'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, que ha desafiado al equipo de userB.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, que ha sido desafiado por el equipo de UserA.')),
        'match' => array('type' => 'node', 'label' => t('Detalles del desafio.')),
      ),
    ),
    'desafio_actualizado' => array(
      'label' => t('UserA ha los detalles del desafio al equipo de userB'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, que ha desafiado al equipo de userB.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, que ha sido desafiado por el equipo de UserA.')),
        'match' => array('type' => 'node', 'label' => t('Detalles del desafio.')),
      ),
    ),
    'desafio_aceptado' => array(
      'label' => t('UserA ha aceptado el desafio del equipo de userB'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, ha aceptado el desafio del equipo de userB.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, ha solicitado enfrentar el equipo de UserA.')),
	'match' => array('type' => 'node', 'label' => t('Detalles del desafio.')),
      ),
    ),
    'desafio_cancelado' => array(
      'label' => t('UserA ha rechazado el desafio del equipo de userB'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, ha rechazado el desafio del equipo de userB.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, ha solicitado enfrentar el equipo de UserA.')),
	'match' => array('type' => 'node', 'label' => t('Detalles del desafio.')),
      ),
    ),
    'partido_programado' => array(
      'label' => t('UserA tiene un partido programado'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, capitan del equipo al que se le ha programado un partido por un torneo.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, usuario del sistema que notifica a UserA del partido programado.')),
	'match' => array('type' => 'node', 'label' => t('Detalles del desafio.')),
      ),
    ),
  );
}
/**	NOT DONE
 * Implementation of hook_views_api()
 */
function match_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'match') .'/views',
  );
}

/**	DONE
 * Implementation of hook_block()
 * @return unknown_type
 */
function match_block($op = 'list', $delta = 0, $edit = array()){
  switch($op){
    case 'list':
      $block = array();
      $block[0]['info'] = t('View upcoming games');
      $block[1]['info'] = t('View latest results');
      $block[2]['info'] = t('Desafiar');
      break;
    case 'view':
      $block_content = '';
      switch($delta){
        case 0:
          //upcoming games
          $block['subject'] = t('Upcoming Matches');
          $block['content'] = l('Desafios Destacados', 'node');
          break;
        case 1:
          //latest results
          $block['subject'] = t('Latest Results');
          $to_show = db_query("SELECT {node}.nid, {node}.title, {signup}.min_pp, {match}.home_team, {match}.away_team FROM {node}, {match}, {signup} WHERE {node}.nid = {match}.nid AND {match}.relation_id = {signup}.nid AND {match}.is_result = 1 ORDER BY {match}.match_time DESC LIMIT %d;", 3);
          $block['content'] = theme('match_block', $to_show);
          break;
        case 2:
          //Desafiar
          if (($content = _match_prepare_desafiar_link()) && ($content <> 'Equipo Incompleto')) {
            $block['subject'] = 'Desafiar';
            $block['content'] = l('Desafiar', $content, array('attributes'=>array('class' => 'popups')));
          }
					elseif ($content == 'Equipo Incompleto') {
            $block['subject'] = 'Desafiar';
            $block['content'] = '<div class="equipo_incompleto">No puduedes desafiar al equipo hasta que este completo</div>';
					}
          break;
      }
      
      break;
    case 'save':
      
      break;
    case 'configure':
      
      break;
  }
  return $block;
}
/**
 * Función para obtener las pruebas que han reportado para los partidos
 *
 * @param
 *  nid_Reto
 *
 * @return
 *  $pruebas[home_team] = 'link';
 *  $pruebas[away_team] = 'link';
 */
function match_get_pruebas($nid_Reto) {
    db_set_active('eSM');
        $pruebas = db_fetch_array(db_query('SELECT * FROM {Prueba} WHERE nid_Reto = %d', $nid_Reto));
    db_set_active('default');
    
    return $pruebas;
}
/**
 * Función para obtener la modalidad de juego a la que pertenece un reto
 *
 * @param
 *  nid_Reto
 *
 * @return
 *  $pruebas[home_team] = 'link';
 *  $pruebas[away_team] = 'link';
 */
function match_get_modalidad_juego($nid_Reto) {
    db_set_active('eSM');
        $result = db_fetch_array(db_query('SELECT {id_Modalidad_Juego } FROM {Modalidad_Juego_Temporada} AS mj INNER JOIN {Reto} AS r ON mj.id_Modalidad_Juego_Temporada = r.id_Modalidad_Juego_Temporada WHERE nid_Reto = %d', $nid_Reto));
    db_set_active('default');
    
    return $result['id_Modalidad_Juego'];
}
/**
 * Función para asignar las reglas de un partido
 *
 * @param
 *  $nid_Reto: El nid_Reto al cual se le tienen que asignar
 *  $numero_rondas: Cuantos conjuntos de reglas se deben asignar
 */
function _match_asignar_reglas ($nid_Reto, $numero_rondas) {
    $modalidad_juego = match_get_modalidad_juego($nid_Reto);
    
    //Obtiene todos los mapas y modalidades de juego de la modalidad de juego
    //$mapas = mapas_get_mapas_modalidad($modalidad_juego);
    $modos = modos_get_modos_modalidad($modalidad_juego);
    
	//Verifica que el arreglo de modos de juego tenga un número de elementos igual o superior al número de rondas
	while (count($modos) < $numero_rondas) {
		$modos = array_merge($modos, $modos);
	}
    //Mezcla los mapas y modos para escoger en órden aleatorio
    //shuffle($mapas);
    shuffle($modos);
    
    for($i = 1; $i <= $numero_rondas; $i++) {
        //Obtien el primer elemento de cada uno de los arreglos de mapa y modo
        //$mapa_regla = array_shift($mapas);
        $modo_regla = array_shift($modos);
        
        db_set_active('eSM');
            db_query('INSERT INTO {Regla} (nid_Reto, id_Modo_Juego) VALUES (%d, %d)', $nid_Reto, $modo_regla);
        db_set_active('default');
    }
}
/**
 * Función para obtener todas las reglas asignadas a un partido
 *
 * @param
 *  $nid_Reto: El nid_Reto al cual se le tienen que asignar
 *
 *  @return
 *   $reglas: Arreglo con todas las reglas asignadas al partido
 */
function _match_obtener_reglas ($nid_Reto) {
    //Obtiene todas las reglas asignadas al partido de la base de datos
    db_set_active('eSM');
        $result = db_query('SELECT * FROM {Regla} WHERE nid_Reto = %d', $nid_Reto);
    db_set_active('default');
    
    $i = 0;
    while ($regla = db_fetch_object($result)) {
        ++$i;
        $reglas[$i]['id_Mapa'] = $regla->id_Mapa;
        $reglas[$i]['id_Modo_Juego'] = $regla->id_Modo_Juego;
    }
    
    return $reglas;
}
/**
 * Función para obtener el resultado reportado por un equipo en un desafio
 *
 * @param
 *  nid_Reto
 *  nid_Equipo
 *
 * @return
 *  objeto con el resultado reportado por el equipo
 *  NULL en caso de que el equipo no haya reportado nada todaví
 */
function _match_get_team_resultado ($nid_Reto, $nid_Equipo) {
	db_set_active('eSM');
		$reporte = db_fetch_object(db_query('SELECT * FROM {Reporte_Reto} WHERE nid_Reto = %d AND nid_Equipo = %d', $nid_Reto, $nid_Equipo));
	db_set_active('default');
    
    return $reporte;
}
/**
 * Función para verificar el estado de un desafio
 *
 * @param
 *   nid_Reto
 */
function _match_check_match($nid_Reto) {
  $reto = node_load($nid_Reto);
  
  $reporte_equipo_local = _match_get_team_resultado($nid_Reto, $reto->nid_Equipo_Local);
  $reporte_equipo_visitante = _match_get_team_resultado($nid_Reto, $reto->nid_Equipo_Visitante);
  $nid_Ganador = 0;
  
  //Verifica si los dos equipos han reportardo su resultado
  if(is_object($reporte_equipo_local) && is_object($reporte_equipo_visitante)) {
    if (($reporte_equipo_local->Resultado == VICTORIA) && ($reporte_equipo_visitante->Resultado == DERROTA)) {
      //Resultado coherente indicando que ganó el equipo local
      $nid_Ganador = $reto->nid_Equipo_Local;
    }
    elseif (($reporte_equipo_local->Resultado == DERROTA) && ($reporte_equipo_visitante->Resultado == VICTORIA)) {
      //Resultado coherente indicando que ganó el equipo visitante
      $nid_Ganador = $reto->nid_Equipo_Visitante;
    }
    
    //Si no hay un ganador definido, entonces el desafío debe ir al estado de conflicto
    if ($nid_Ganador == 0) {
      _match_update_match($nid_Reto, CONFLICTO);
    }
    else {
      _match_end_match($nid_Reto, $nid_Ganador);
    }
  }
}

/**
 * Función para actualizar el estado de un desafio
 *
 * @param
 *   nid_Reto
 *   Estado
 */
function _match_update_match($nid_Reto, $estado) {
    db_set_active('eSM');
      db_query('UPDATE {Reto} SET Estado = %d WHERE nid_Reto = %d', $estado, $nid_Reto);
    db_set_active('default');
    
    //TODO: Ejectuar acciones o enviar notificaciones de acuerdo al estado del match
}
/**
 * Función para poner un desafio en estado COMPLETADO
 * calcula las nuevas puntuaciones de los equipos
 * guarda el ganador del match en la tabla Fin_Reto
 * llama a las funciones para actualizar el ránking o los brackets
 *
 * @param
 *   nid_Reto
 *   nid_Ganador
 */
function _match_end_match($nid_Reto, $nid_Ganador) {
	$reto = node_load($nid_Reto);
    
    if ($reto->Tipo == IS_TORNEO) {
      //Para los desafios de torneos, las puntuaciones finales son iguales a las puntuaciones iniciales
      db_set_active('eSM');
        db_query('INSERT INTO {Fin_Reto}
                 (nid_Reto, Puntuacion_Final_Equipo_Local, Puntuacion_Final_Equipo_Visitante, nid_Equipo_Ganador)
                 VALUES (%d, %d, %d, %d)',
                 $nid_Reto, $reto->Puntuacion_Inicial_Equipo_Local, $reto->Puntuacion_Inicial_Equipo_Visitante, $nid_Ganador);
      db_set_active('default');
      
      //Obtiene el torneo del que forma parte el desafio
      db_set_active('eSM');
        $Torneo = db_fetch_object(db_query('SELECT * FROM {Retos_Torneos} WHERE nid_Reto = %d', $nid_Reto));
      db_set_active('default');
      
      //Actualiza los brackets del torneo
      _torneo_update_bracket($Torneo->nid_Torneo, $nid_Ganador);
    }
    else {
      //Calcula las puntuaciones finales para los dos equipos en base a la tabla definida en el ránking
      _ranking_calcula_desafio($reto->nid_Equipo_Local, $reto->nid_Equipo_Visitante, $nid_Ganador, $reto->Puntuacion_Inicial_Equipo_Local, $reto->Puntuacion_Inicial_Equipo_Visitante);
	  
	  //Avisa a los capitanes que se ha completado el reto y actualizado las puntuaciones
	  $home_team = node_load(array('nid' => $reto->nid_Equipo_Local));
	  $home_capitan = user_load(array('uid' => $home_team->uid));
	  $away_team = node_load(array('nid' => $reto->nid_Equipo_Visitante));
	  $away_capitan = user_load(array('uid' => $away_team->uid));
	  rules_invoke_event('raking_actualizado_desafio', $home_team, $home_capitan, $reto);
	  rules_invoke_event('raking_actualizado_desafio', $away_team, $away_capitan, $reto);

      //Obtiene las puntuaciones finales de cada equipo
      $puntuacion_local = _ranking_get_team_puntuacion($reto->nid_Equipo_Local);
      $puntuacion_visitante = _ranking_get_team_puntuacion($reto->nid_Equipo_Visitante);
      
      //Guarda los datos en Fin_Reto
      db_set_active('eSM');
        db_query('INSERT INTO {Fin_Reto}
                 (nid_Reto, Puntuacion_Final_Equipo_Local, Puntuacion_Final_Equipo_Visitante, nid_Equipo_Ganador)
                 VALUES (%d, %d, %d, %d)',
                 $nid_Reto, $puntuacion_local->Puntuacion, $puntuacion_visitante->Puntuacion, $nid_Ganador);
      db_set_active('default');
    }
    
    //Actualiza el estado del reto a COMPLETADO
    _match_update_match($nid_Reto, COMPLETADO);
}
/**
 * Función para crear un reporte de mala conducta para un equipo
 *
 * @param
 *  nid_Reto
 *  nid_Equipo
 *  Reporte:  0 => 'Seleccione una',
              1 => 'Insultos o amenazas',
              2 => 'Comentarios ofensivos',
              3 => 'Juego sucio o trampas',
 */
function _match_crear_reporte_mala_conducta ($nid_Reto, $nid_Equipo, $conducta) {
  db_set_active('eSM');
    db_query('INSERT INTO {Reto_Conducta} (nid_Reto, nid_Equipo, Reporte, Estado) VALUES (%d, %d, %d, %d)', $nid_Reto, $nid_Equipo, $conducta, 0);
  db_set_active('default');
  
  //TODO: Mandar un mensaje al coordinador deportivo para que revise el estado del reporte.
}
/**
 * Función para preparar el link para que los equipos se puedan desafiar entre ellos
 */
function _match_prepare_desafiar_link() {  
	//Carga el nodo
	if (arg(0) == 'node' && is_numeric(arg(1)))
		$node = node_load(arg(1));
			
	//Revisa que el nodo pertenezca a un equipo
	if ($node->type == 'team') {
		//Obtiene los datos de la modalidad
		$modalidad = get_modalidad($node->id_Modalidad_Juego_Temporada);

		//Revisa que el equipo tenga el mínimo de integrantes necesarios para la modalidad
		if ($node->Numero_Integrantes >= $modalidad->Minimo_Jugadores)
			//Prepara el link para desafiar a este equipo
			$link = 'taxonomy/term/'. $modalidad->tid .'/defy/'. $node->nid;
		else
			$link = 'Equipo Incompleto';
	}
	
	return $link;
}
/**
 * Función para preparar el despliegue de la reputación del equipo
 */
function _match_display_reputation($nid) {
		//Prepara el link para desafiar a este equipo
		$vote = _votingapi_get_standard_results('team', $nid);
		
		return theme('match_fivestar_static', $vote['vote']['percent']['average'], 5, 'vote');
}
/**
 * Función para obtener una lista de los matches que coinciden con un criterio
 *
 * @param
 *  nid_Equipo
 *  $criterio
 *
 * @return
 *  mysql object
 */
function _match_get_team_match_list ($nid_Equipo, $criterio) {
  db_set_active('eSM');
    $query = db_query('SELECT * FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ir ON r.nid_Reto = ir.nid_Reto
                      WHERE (ir.nid_Equipo_Local = %d OR ir.nid_Equipo_Visitante = %d) AND r.Estado = %d
					  ORDER BY Fecha_Inicio DESC',
                      $nid_Equipo, $nid_Equipo, $criterio);
  db_set_active('default');
  
  return $query;
}
/**
 * Función para obtener una lista de los matches que coinciden con un criterio
 *
 * @param
 *  nid_Equipo
 *  $criterio
 *
 * @return
 *  mysql object
 */
function _match_modalidad_get_match_list ($id_Modalidad_Juego_Temporada, $criterio) {
  db_set_active('eSM');
    $query = db_query('SELECT * FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ir ON r.nid_Reto = ir.nid_Reto
                      WHERE id_Modalidad_Juego_Temporada = %d AND r.Estado = %d
					  ORDER BY Fecha_Inicio DESC',
                      $id_Modalidad_Juego_Temporada, $criterio);
  db_set_active('default');
  
  return $query;
}
/**
 * Función para obtener una lista de los matches que coinciden con un criterio
 *
 * @param
 *  nid_Equipo
 *  $criterio
 *
 * @return
 *  mysql object
 */
function _match_torneo_get_match_list ($nid_Torneo, $criterio) {
  db_set_active('eSM');
    $query = db_query('SELECT * FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ir ON r.nid_Reto = ir.nid_Reto
					  INNER JOIN {Retos_Torneos} AS rt ON r.nid_Reto = rt.nid_Reto
                      WHERE nid_Torneo = %d AND r.Estado = %d
					  ORDER BY Ronda DESC',
                      $nid_Torneo, $criterio);
  db_set_active('default');
  
  return $query;
}
/**
 * Función para obtener el resultado de un partido
 * @param
 *  nid_Reto
 *
 * @return
 *  Objeto con el resulatdo de un partido
 */
function _match_get_resultado ($nid_Reto) {
  db_set_active('eSM');
    $resultado = db_fetch_object(db_query('SELECT * FROM {Fin_Reto} WHERE nid_Reto = %d', $nid_Reto));
  db_set_active('default');
  
  return $resultado;
}