<?php
// $Id: match.module,v 1.19 2010/04/15 18:35:03 alun Exp $


// Define los estados del desafío
	define( 'CREADO', 0 );
  define( 'PROGRAMADO', 1 );
	define( 'CANCELADO', 2 );
  define( 'COMPLETADO', 3 );

/**	DONE
* Implementation of hook_perm()
* Outlines permissions for this module.
* @return array - An array of valid permissions for the match module
*/
function match_perm( ){
  return array( 'administer matches', 'create match', 'edit own match', 'delete own match', 'enter own match results', 'matches viewing' );
}//end function match_perm()


/**	DONE
 * Implementation of hook_menu()
 * Sets up the admin menu system for the matches.
 */
function match_menu(){
  $items['matchadmin'] = array(
    'title' => 'Match Admin',
    'description' => t('View and enter pending results'),
    'page callback' => 'match_admin',
    'access arguments' => array('administer matches'),
    'file' => 'inc/match.admin.inc',
  );
  $items['admin/settings/matches'] = array(
    'title' => 'Match Settings',
    'description' => t('Set various options for match entry'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_settings'),
    'access arguments' => array('administer matches'),
    'file' => 'inc/match.admin.inc',
  );
  $items['node/%node/edit/match'] = array(
    'title' => 'Match',
    'access callback' => 'match_edit_access',
    'access arguments' => array(1),
    'weight' => -10,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['node/%node/edit/score'] = array(
    'title' => 'Result',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_score_edit'),
    'access callback' => 'match_report_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
    'file' => 'inc/match.admin.inc',
  );
	
  $items[ 'taxonomy/term/%/challenges' ] = array
	(
    'title' => 'Tablero de desafíos',
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'challenges_binnacle' ),
    //'access callback' => 'matches_viewing',
    'access arguments' => array( 'matches_viewing' ),
    'type' => MENU_CALLBACK,
    //'file' => 'inc/match.admin.inc',
  );
	
  $items[ 'taxonomy/term/%/challenges/create' ] = array
	(
    'title' => 'Crear un desafío',
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'indirect_match_form' ),
    'access callback' => 'match_report_access',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    //'file' => 'inc/match.admin.inc',
  );
	
	$items[ 'node/%node/desafiar/' ] = array
	(
    'title' => 'Desafiar',
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'direct_match_form' ),
    //'access callback' => 'match_report_access',
    'access arguments' => array( 'create match' ),
    'type' => MENU_LOCAL_TASK,
    //'file' => 'inc/match.admin.inc',
  );
	
	
	$items[ 'node/%node/desafios/' ] = array
	(
    'title' => 'Desafiar',
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'team_challenges_binnacle' ),
    //'access callback' => 'match_report_access',
    'access arguments' => array( 'create match' ),
    'type' => MENU_LOCAL_TASK,
    //'file' => 'inc/match.admin.inc',
  );
	
  return $items;
}







/**	DONE
 * Implementation of hook_node_info()
 * Declare the content type match
 * 
 */ 
function match_node_info() {
	
	global $user;
	
  return array
	(
		'match' => array
		(
			'name' => t('Desafío'),
			'module' => 'match',
			'description' => t("Un partido entre dos equipos integrados a la puntuación."),
		)
	);
} 

/**	DONE
 *
 * Access argument for the node edit page - just return node access for updating the node
 */
function match_edit_access( $node )
{
  return node_access( 'update', $node );
}

/**	DONE
 *	Access argument for the node report score page -
 *	just return node access for users who have permission to report the match score
 */
function match_report_access( ) {
  global $user;
  
  //users who can administer matches can do anything.
  if ( user_access( 'administer matches') )
    return TRUE;
  
  //Revisa que el usuario sea el capitán/creador de alguno de los dos equipos en el match
  //$home_team = node_load( $node->home_team );
  //$visitor_team = node_load( $node->visitor_team );
  
  if ( $user->uid == $home_team->uid || $user->uid == $visitor_team->uid)
      return TRUE;
    
  return FALSE;
}

/** DONE
 * Implementation of hook_access()
 */
function match_access($op, $node, $account){
  //users who can administer matches can do anything.
  if ( user_access('adminster matches', $account ) )
    return TRUE;
  
  if ($op == 'create') {
    // Only users with permission to do so may create this node type.
    return user_access('create match', $account);
  }
  
  if ($op == 'update') {
    if (user_access('edit own match', $account) && ($account->uid == $node->uid)) {
      return TRUE;
    }
    /* No lo elimino, pero no se a que se refiere
    while($row = db_fetch_array($result)){
      if(user_access('enter results', $account) && ($account->uid == $row['uid'])){
        return TRUE;
      }
    }*/
  }
  
  if ($op == 'delete') {
    if(user_access('delete own match', $account) && ($account -> uid == $node ->uid)) {
      return TRUE;
    }
    /*Lo mismo que arriba, no se si se intentaba utilizar con los og groups o que
    while($row = db_fetch_array($result)){
      if(user_access('delete own match', $account) && ($account->uid == $row['uid'])){
        return TRUE;
      }
    }*/
  }
  
  if ($op == 'view') {
    if(user_access('access content', $account)) {
      return TRUE;
    }
  }
  return FALSE;
} 




/**	ALMOST DONE
 * Implementation of hook_load()
 */
function match_load( $node )
{
  
	$Retos = db_fetch_object( db_query( 'SELECT { Reto } AS { r } INNER JOIN { Inicio_Reto } AS { ir } ON { r.id_Reto = ir.id_Reto } INNER JOIN { Jugador }  AS { j } ON { j.id_Modalidad_juego_Temporada }' ) );
	
	
	
	
	
	//get the additional match information and attach to the node
	/*if(  )
	{
		
		
		
	}*/
	
	
	
	$teams = db_fetch_array(db_query("SELECT {match}.home_team, {match}.away_team, {match}.home_score, {match}.away_score, {match}.match_time, {match}.is_result, {match}.relation_id FROM {match} WHERE {match}.nid = %d;", intval($node->nid)));
	
	
  $node->is_result = $teams['is_result'];
  $node->home_team = $teams['home_team'];
  $node->away_team = $teams['away_team'];
  $node->season_league = $teams['relation_id'];
  $node->match_time = array('year' => date('Y', $teams['match_time']),  'month' => date("n", $teams['match_time']), 'day' => date("j", $teams['match_time']));
  $node->match_hour = date('G', $teams['match_time']);
  $node->match_minute = date('i', $teams['match_time']);
  //check if the score has not been entered yet
  if($teams['is_result'] == 0){
    $node->home_score = '';
    $node->away_score = ''; 
  }else{
    $node->home_score = $teams['home_score'];
    $node->away_score = $teams['away_score'];
  }
  
  //load additional match data using hook_match_load
  module_invoke_all('match_load', $node);
  
  return $node;
}

/** NOT DONE
 * Implementation of hook_insert()
 */
function match_insert( $node )
{
  //add the extra details
  if( $node->home_score != '' && $node->away_score != '' && variable_get('match_update_table_insert', '') == TRUE) {
    _match_update_table($node->home_team, $node->away_team, $node->home_score, $node->away_score, $node->season_league);
    $is_result = 1;
  }
  //TODO: use this hook
  module_invoke_all('match_insert', $node);
  $match_time = mktime($node->match_hour, $node->match_minute, 0, intval($node->match_time['month']), intval($node->match_time['day']), intval($node->match_time['year']));
  db_query("INSERT INTO {match} (nid, home_team, away_team, match_time, home_score, away_score, is_result, relation_id) VALUES (%d, %d, %d, %d, '%s', '%s', %d, %d)", intval($node->nid), intval($node->home_team), intval($node->away_team), check_plain($match_time), check_plain($node->home_score), check_plain($node->away_score), intval($is_result), intval($node->season_league));
  
  _match_send_notification_mail($node);
}

/**	NOT DONE
 * Implementation of hook_update()
 * @param Object $node
 */
function match_update($node){
  //update the extra details
  $is_result = 0;
  if(variable_get('match_update_table_update', '') == TRUE){
    $match = db_fetch_array(db_query("SELECT * FROM {match} WHERE nid = %d", intval($node->nid)));
    if($node->home_score != '' && $node->away_score != ''){
      //after checking if the user wants the standings table updated, get the old score to see if it has changed
      $is_result = 1;
      if(($match['home_score'] != $node->home_score || $match['away_score'] != $node->away_score) && ($match['is_result'] == 1)){
        //delete old score values
        _match_update_table($match['home_team'], $match['away_team'], $match['home_score'], $match['away_score'], $match['relation_id'], 'delete'); 
        _match_update_table($node->home_team, $node->away_team, $node->home_score, $node->away_score, $node->season_league);
      }else if($match['is_result'] == 0){
        _match_update_table($node->home_team, $node->away_team, $node->home_score, $node->away_score, $node->season_league);
        $report_time = time();
        if (module_exists('userpoints')) 
          _match_update_exp($node->home_team, $node->away_team, $node->home_score, $node->away_score, $node->season_league);
      }
    }else{
      if($match['is_result'] == 1){
        //the match result has been removed. use the database to update the table appropriately
        _match_update_table($match['home_team'], $match['away_team'], $match['home_score'], $match['away_score'], $match['relation_id'], 'delete');
      }
    }
  }
  //call event_manager hook for an updated game
  module_invoke_all('match_update', $node);
  
  $match_time = mktime($node->match_hour, $node->match_minute, 0, intval($node->match_time['month']), intval($node->match_time['day']), intval($node->match_time['year']));
  db_query("UPDATE {match} SET home_team = %d, away_team = %d, match_time = %d, report_time = %d, home_score = '%s', away_score = '%s', is_result = %d, relation_id = %d WHERE nid = %d;", intval($node->home_team), intval($node->away_team), check_plain($match_time), check_plain($report_time), check_plain($node->home_score), check_plain($node->away_score), intval($is_result), intval($node->season_league), intval($node->nid));
}

/**	NOT DONE
 * Implementation of hook_delete()
 * @param Object $node
 */
function match_delete($node){
  //delete the extra details
  $match = db_fetch_array(db_query("SELECT * FROM {match} WHERE nid = %d", intval($node->nid)));
  //check if a match result exists. If so, check if we should udpate the league tables to reflect the deletion of the match
  if($match['is_result'] == 1 && variable_get('match_update_table_delete', '') == TRUE){
    //node is not completely built here, only basic information is available, so we use the database info instead.
    _match_update_table($match['home_team'], $match['away_team'], $match['home_score'], $match['away_score'], $match['relation_id'], 'delete');
  }
  
  db_query("DELETE FROM {match} WHERE nid = %d", intval($node->nid));
  
  module_invoke_all('match_delete', $node);
}

/**	NOT DONE
 * Function that update the laddeer or bracket table for reflect the reported results
 * @param
 * $home_team: Home team id
 * $away_team: Away team id
 */
function _match_update_table($home_team, $away_team, $home_score, $away_score, $relation_id, $op = "insert"){
  $event_settings = db_fetch_array(db_query("SELECT type FROM {event_manager_settings} WHERE nid = %d", $relation_id));

    if($op == "insert") {
      switch ($event_settings['type']) {
        case 1:					//Tornament promotions
          $team = db_fetch_array(db_query("SELECT * FROM {event_manager_brackets} WHERE nid= %d and pid  = %d ORDER BY round DESC LIMIT 1", $relation_id, $home_team));
          $newpos = ceil((float)$team['pos'] / 2.0 );
          $newround = $team['round'] + 1;
          
          db_query("INSERT INTO {event_manager_brackets} (nid, pid, round, pos)VALUES (%d, %d, %d, %d)", $relation_id, ($home_score > $away_score ? $home_team : $away_team), $newround, $newpos);

          break;
        case 2:					//Ladder event whit ELO points so we calculate the updates on the points winning for each team
          $home_standing = db_fetch_array(db_query("SELECT * FROM {event_manager_ladders} WHERE nid = %d AND pid = %d", $relation_id, $home_team));
          $away_standing = db_fetch_array(db_query("SELECT * FROM {event_manager_ladders} WHERE nid = %d AND pid = %d", $relation_id, $away_team));

          // was it a win, draw or loss? figure out the standings results
          if($home_score > $away_score) {
            ++$home_standing['wins'];
            if($home_standing['streak'] > 0)
              ++$home_standing['streak'];
            else
              $home_standing['streak'] = 1;
            ++$away_standing['loss'];
            if($away_standing['streak'] < 1)
              --$away_standin['streak'];
            else
              $away_standing['streak'] = -1;
          }
          else if($home_score == $away_score) {
            ++$home_standing['drawn'];
            ++$away_standing['drawn'];
          }
          else {
            ++$home_standing['loss'];
            if($home_standing['streak'] < 1)
              --$home_standing['streak'];
            else
              $home_standing['streak'] = -1;
            ++$away_standing['wins'];
            if($away_standing['streak'] > 0)
              ++$away_standin['streak'];
            else
              $away_standing['streak'] = 1;
          }
          ++$home_standing['games'];
          ++$away_standing['games'];

          $home_new_points = $home_standing['points']+50*(($home_score/($home_score+$away_score))-(1/(1+10^(-($home_score-$away_score)/400))));
          $away_new_points = $away_standing['points']+50*(($away_score/($home_score+$away_score))-(1/(1+10^(-($away_score-$home_score)/400))));

          db_query("UPDATE {event_manager_ladders} SET wins = %d, loss = %d, games = %d, points = %d WHERE pid = %d AND nid = %d;", $home_standing['wins'], $home_standing['loss'], $home_standing['games'], $home_new_points, $home_team, $relation_id);
          //now away team
          db_query("UPDATE {event_manager_ladders} SET wins = %d, loss = %d, games = %d, points = %d WHERE pid = %d AND nid = %d;", $away_standing['wins'], $away_standing['loss'], $away_standing['games'], $away_new_points, $away_team, $relation_id);
          break;
      }
    }
}

/**	NOT DONE
 * Implementation of hook_validate
 * Validates the match type before submission to ensure that the setup is correct
 * @param Object $node
 * @param Array $form
 */
function match_validate($node, $form){
  //Check that both results are entered if any are entered

  if($node->home_score != '' && $node->away_score == ''){
    form_set_error('away_score', t('If you enter a home team score, you should enter an away team score.'));
  }else if($node->home_score == '' && $node->away_score != ''){
    form_set_error('home_score', t('If you enter an away team score, you should enter a home team score.'));
  }
  
  //Check that a team is not playing itself
  if($node->home_team == $node->away_team){
    form_set_error('away_team', t('A team cannot play itself!'));
  }
  //TODO: check that both those teams exist within that season
}

/** NOT DONE
 * Implementation of hook_form_FORM_ID_alter
 * This sets the default team correctly on the dropdown boxes on the generated form
 */
function match_form_match_node_form_alter(&$form, $form_state){
  if(is_numeric($form['nid']['#value'])){
    if(!variable_get('match_change_teams', '')){
      //remove the team fields so people cannot change the teams
      $form['home_team']['#disabled'] = TRUE;
      $form['away_team']['#disabled'] = TRUE;
      $form['season_league']['#disabled'] = TRUE;
    }
  }
}

/**	NOT DONE
 * Implementation of hook_submit
 * Alters the title of the node before submission - otherwise it would be blank
 * @param Object $node
 */
function match_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL){
  if($op == 'presave' && $node->type == 'match'){
  //get the title. query the database to get the title of the teams.
    $season = db_fetch_array(db_query("SELECT min_pp FROM {signup} WHERE nid = %d", $node->season_league));
    if ($season['min_pp'] > 1) {
      $team = db_fetch_array(db_query("SELECT title FROM {node} WHERE nid = %d;", $node->home_team));
      $home_team = $team['title'];
      $team = db_fetch_array(db_query("SELECT title FROM {node} WHERE nid = %d;", $node ->away_team));
      $away_team = $team['title'];
    }
    else {
      $team = db_fetch_array(db_query("SELECT name FROM {users} WHERE uid = %d;", $node->home_team));
      $home_team = $team['name'];
      $team = db_fetch_array(db_query("SELECT name FROM {users} WHERE uid = %d;", $node ->away_team));
      $away_team = $team['name'];
    }
    $search = array('[home_team]', '[away_team]');
    $replace = array($home_team, $away_team);
    if(module_exists('event_manager_scoring')){
    	if(!isset($node->match_attributes)){
    		//the attributes aren't set on the form we came from, so we don't have a result to enter. Load the last state of the node, and take the results from there
    		$old_node = node_load($node->nid);
    		if($old_node->is_result){
    		  $node->home_score = $old_node->home_score;
    		  $node->away_score = $old_node->away_score;
    		}
    	}else{
        event_manager_scoring_calculate_score($node);
    	}
    }
    //if the match is a result, home_score will be a number
    if($node->home_score != ''){
    	
    	$search[] = '[home_score]';
    	$search[] = '[away_score]';
    	$replace[] = $node->home_score;
    	$replace[] = $node->away_score;
      //set the title to have the score in it.
      
      $title = str_replace($search, $replace, variable_get('match_general_result_name', '[home_score] [home_team] - [away_score] [away_team]'));
    	//$title = $home_team.' '.$node->home_score.' - '.$away_team.' '.$node->away_score;
      //the standings are updated in hook_update and hook_insert
    }else{
      $title = str_replace($search, $replace, variable_get('match_general_match_name', '[home_team] v [away_team]'));
    	//$title = $home_team.' v '.$away_team;
    }
    $node->title = $title;
  }
}

/**	NOT DONE
 * Implementation of hook_view()
 * @param $node
 * @param $teaser
 * @param $page
 * @return unknown_type
 */
function match_view($node, $teaser = FALSE, $page = FALSE){  
  $content = theme('match_content', $node);
    
  $node->title = '';
  $node->content[] = array(
    '#value' => $content, 
    '#weight' => '0',
  );
  
  return $node;
}

/**	NOT DONE
 * Implementation of hook_theme()
 * 
 */
function match_theme($existing, $type, $theme, $path) {
  return array(
    'match_list' => array(
      'arguments' => array('form' => NULL),
      'file' => 'inc/match.admin.inc',
    ),
    'match_node_form' => array(
      'file' => 'node.inc',
      'path' => drupal_get_path('module', 'match') .'/theme',
      'arguments' => array('form' => NULL),
    ),
    'match_content' => array(
      'file' => 'node_content.inc',
      'path' => drupal_get_path('module', 'match') .'/theme',
      'arguments' => array('node'),
    ),
    'match_block' => array(
      'file' => 'block.inc',
      'path' => drupal_get_path('module', 'match') .'/theme',
      'arguments' => array('content'),
    ),
    'match_filters' => array(
      'arguments' => array('form' => NULL),
      'file' => 'inc/match.admin.inc',
    ),
    'match_score_edit' => array(
      'arguments' => array('form' => NULL),
      'file' => 'inc/match.admin.inc',
    ),
  );
}

/**	NOT DONE
 * Implementation of hook_views_api()
 */
function match_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'match') .'/views',
  );
}

/**	NOT DONE
 * Implementation of hook_block()
 * @return unknown_type
 */
function match_block($op = 'list', $delta = 0, $edit = array()){
  switch($op){
    case 'list':
      $blockArray = array();
      $blockArray[0]['info'] = t('View upcoming games');
      $blockArray[1]['info'] = t('View latest results');
      return $blockArray;
      break;
    case 'view':
      $block_content = '';
      switch($delta){
        case 0:
          //upcoming games
          $block['subject'] = t('Upcoming Matches');
          $to_show = db_query("SELECT {node}.nid, {node}.title, {signup}.min_pp, {match}.home_team, {match}.away_team FROM {node}, {match}, {signup} WHERE {node}.nid = {match}.nid AND {match}.relation_id = {signup}.nid AND {match}.is_result = 0 ORDER BY {match}.match_time ASC LIMIT %d;", 3);
          break;
        case 1:
          //latest results
          $block['subject'] = t('Latest Results');
          $to_show = db_query("SELECT {node}.nid, {node}.title, {signup}.min_pp, {match}.home_team, {match}.away_team FROM {node}, {match}, {signup} WHERE {node}.nid = {match}.nid AND {match}.relation_id = {signup}.nid AND {match}.is_result = 1 ORDER BY {match}.match_time DESC LIMIT %d;", 3);
          break;
      }
      $block['content'] = theme('match_block', $to_show);
      return $block;
      break;
    case 'save':
      
      break;
    case 'configure':
      
      break;
  }
}

/**	NOT DONE
 * Send the notification e-mail to the users who are participating on match.
 * 
 *
 * @param $node
 *   The fully-loaded node object which the user signed up to.
 *   
 * @return
 *   The return value from drupal_mail() if the mail is sent, or FALSE if the
 *   confirmation was aborted for some reason (node not configured to send it,
 *   user doesn't have a valid e-mail address, etc).
 *  
 */
function _match_send_notification_mail($node) {

  $params = array(
    'subject' => t( 'Tienes un partido pendiente: !title', array( '!title' => $node->title ) ),
    'body' => '¡Has sido desafiado!',
    'node' => $node,
  );
  
  $seasson = node_load( $node->relation_id );
  if ( $seasson->signup_min_pp <= 1 )
	{
    $home_team = user_load($node->home_team);
    $home_language = user_preferred_language($home_team);
    $away_team = user_load($node->away_team);
    $away_language = user_preferred_language($away_team);
  }
  drupal_mail('match', 'match_create_mail', $home_team->mail, $language, $params);
  drupal_mail('match', 'match_create_mail', $away_team->mail, $language, $params);
}

/**	NOT DONE
 * Implementation of hook_mail().
 *
 * Constructs all of the email messages generated by the signup module.
 *
 * @param $key
 *   Unique key to indicate what message to build.
 * @param $message
 *   Reference to the message array being built.
 * @param $params
 *   Array of parameters to indicate what text to include in the message body.
 *   If $params['ignore_tokens'] is TRUE, none of the signup-provided tokens
 *   in the message body will be replaced, otherwise, tokens are replaced
 *   using the node passed in as $params['node'] and the signup data from
 *   $params['signup'].
 *
 * @see drupal_mail()
 * @see _signup_cron_send_reminders()
 * @see signup_sign_up_user()
 * @see signup_broadcast_form_submit()
 */
function match_mail($key, &$message, $params) {
  if (empty($params['ignore_tokens'])) {
    $tokens = _signup_get_email_tokens($params['node'], $params['signup']);
    $body = strtr($params['body'], $tokens);
    $subject = strtr($params['subject'], $tokens);
  }
  else {
    $body = $params['body'];
    $subject = $params['subject'];
  }
  $message['subject'] .= str_replace(array("\r", "\n"), '', $subject);
  $message['body'][] = $body;
}



/**	ALMOST DONE
 *	Función que se encargará de mostrar la bitácora de desafíos creados para las modalidades
 *	y temporadas activas al momento
 */
function challenges_binnacle( )
{
	
	module_load_include( 'php', 'base_datos_externa', 'db_functions' );
	
	$date = '2011-12-31';
	$format = 'Y-m-d H:i';
	
	$tid_Modalidad_Juego = arg( 2 );
	$Temporada_Activa = temporada_activa(  );
	
	db_set_active( 'eSM' );
		$Challenges_result_set = db_query( 'SELECT { * } FROM { Reto } AS { r } INNER JOIN { Modalidad_Juego_Temporada } AS { mjt } ON { r.id_Modalidad_Juego_Temporada = mjt.id_Modalidad_Juego_Temporada } INNER JOIN { Temporada } AS { t } ON { mjt.id_Temporada = t.id_Temporada } INNER JOIN { Modalidad_Juego } AS { mj } ON { mjt.id_Modalidad_Juego = mj.id_Modalidad_Juego } WHERE { mj.tid = %d } AND { t.id_Temporada = %d } AND { r.Estado = %d }', $tid_Modalidad_Juego, $Temporada_Activa->id_Temporada, CREADO );
	db_set_active( 'default' );

	if ( $Challenges_result_set->num_rows )
	{

			/*$form[ 'Challenges_List' ] = array
			(
			
				'#type' => 'fieldset',
				'#title' => 'Lista de desafíos',
				'#collapsible' => 'FALSE',
				'#collapsed' => 'FALSE',
			 
			);*/		
	
		
		
		while( $Challenge = db_fetch_object( $Challenges_result_set ) )
		{
			


			
			$Fecha_Inicio = timestamp_to_string( $Challenge->Fecha_Inicio );
			$Fecha_Fin = timestamp_to_string( $Challenge->Fecha_Fin );
	
			
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'id_Reto' ] = array
			(
				'#type' => 'item',
				//'label' => t( 'Nombre' ),
				//'#disabled' => 'TRUE',
				//'size' => 17,
				//'maxlength' => 17,
				'#title' => t( 'Número de reto' ),
				//'#required' => TRUE,
				'#weight' => -8,
				'#value' => $Challenge->id_Reto,
			);
			
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'Fecha_Inicio' ] = array (
				'#type' => 'date_text', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
				'#disabled' => 'TRUE',
				'#title' => 'Fecha de inicio',
				'#default_value' => $Fecha_Inicio,
				'#date_format' => $format,
				'#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
				'#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
				'#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
				'#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
				'#size' => 17,
				'#maxlength' => 17,
			);
	
	
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'Fecha_Fin' ] = array (
				'#type' => 'date_text', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
				'#disabled' => 'TRUE',
				'#title' => 'Fecha de inicio',
				'#default_value' => $Fecha_Fin,
				'#date_format' => $format,
				'#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
				'#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
				'#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
				'#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
				'#size' => 17,
				'#maxlength' => 17,
			);
	
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'Estado' ] = array (
				'#type' => 'item', 
				'#title' => 'Estado',
				'#value' => $Challenge->Estado,
			);
		
		
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'Aceptar' ] = array
			(
				
				'#type' => 'submit',
				'#value' => t('Aceptar desafío'),
				
			);
			
		}	
		
		$form[ 'tid_Modalidad_Juego' ] = array
		(		
			'#type' => 'hidden',
			'#value' => $tid_Modalidad_Juego,
		);
		
		
		
		$form[ 'id_Temporada_Activa' ] = array
		(		
			'#type' => 'hidden',
			'#value' => $Temporada_Activa,
		);

	}
	
	else
	{
		
		$form[ 'Message' ] = array
		(
			
			'#type' => 'item',
			'#value' => t( 'No hay desafíos disponibles para esta modalidad' ),
			
		);
		
	}
	
	
	return $form;
	
}



/**	ALMOST DONE
 *	Función que se encargará de mostrar la bitácora de desafíos creados para las modalidades
 *	y temporadas activas al momento
 */
function team_challenges_binnacle( )
{
	
	module_load_include( 'php', 'base_datos_externa', 'db_functions' );
	
	$date = '2011-12-31';
	$format = 'Y-m-d H:i';
	
	$tid_Modalidad_Juego = arg( 2 );
	$Temporada_Activa = temporada_activa(  );
	
	db_set_active( 'eSM' );
		$Challenges_result_set = db_query( 'SELECT { * } FROM { Reto } AS { r } INNER JOIN { Modalidad_Juego_Temporada } AS { mjt } ON { r.id_Modalidad_Juego_Temporada = mjt.id_Modalidad_Juego_Temporada } INNER JOIN { Temporada } AS { t } ON { mjt.id_Temporada = t.id_Temporada } INNER JOIN { Modalidad_Juego } AS { mj } ON { mjt.id_Modalidad_Juego = mj.id_Modalidad_Juego } WHERE { mj.tid = %d } AND { t.id_Temporada = %d } AND { r.Estado = %d }', $tid_Modalidad_Juego, $Temporada_Activa->id_Temporada, CREADO );
	db_set_active( 'default' );

	if ( $Challenges_result_set->num_rows )
	{

			/*$form[ 'Challenges_List' ] = array
			(
			
				'#type' => 'fieldset',
				'#title' => 'Lista de desafíos',
				'#collapsible' => 'FALSE',
				'#collapsed' => 'FALSE',
			 
			);*/		
	
		
		
		while( $Challenge = db_fetch_object( $Challenges_result_set ) )
		{
			


			
			$Fecha_Inicio = timestamp_to_string( $Challenge->Fecha_Inicio );
			$Fecha_Fin = timestamp_to_string( $Challenge->Fecha_Fin );
	
			
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'id_Reto' ] = array
			(
				'#type' => 'item',
				//'label' => t( 'Nombre' ),
				//'#disabled' => 'TRUE',
				//'size' => 17,
				//'maxlength' => 17,
				'#title' => t( 'Número de reto' ),
				//'#required' => TRUE,
				'#weight' => -8,
				'#value' => $Challenge->id_Reto,
			);
			
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'Fecha_Inicio' ] = array (
				'#type' => 'date_text', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
				'#disabled' => 'TRUE',
				'#title' => 'Fecha de inicio',
				'#default_value' => $Fecha_Inicio,
				'#date_format' => $format,
				'#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
				'#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
				'#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
				'#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
				'#size' => 17,
				'#maxlength' => 17,
			);
	
	
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'Fecha_Fin' ] = array (
				'#type' => 'date_text', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
				'#disabled' => 'TRUE',
				'#title' => 'Fecha de inicio',
				'#default_value' => $Fecha_Fin,
				'#date_format' => $format,
				'#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
				'#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
				'#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
				'#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
				'#size' => 17,
				'#maxlength' => 17,
			);
	
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'Estado' ] = array (
				'#type' => 'item', 
				'#title' => 'Estado',
				'#value' => $Challenge->Estado,
			);
		
		
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'Aceptar' ] = array
			(
				
				'#type' => 'submit',
				'#value' => t('Aceptar desafío'),
				
			);
			
		}	
		
		$form[ 'tid_Modalidad_Juego' ] = array
		(		
			'#type' => 'hidden',
			'#value' => $tid_Modalidad_Juego,
		);
		
		
		
		$form[ 'id_Temporada_Activa' ] = array
		(		
			'#type' => 'hidden',
			'#value' => $Temporada_Activa,
		);

	}
	
	else
	{
		
		$form[ 'Message' ] = array
		(
			
			'#type' => 'item',
			'#value' => t( 'No hay desafíos disponibles para esta modalidad' ),
			
		);
		
	}
	
	
	return $form;
	
}




/**	ALMOST DONE
 * Implementation of hook_form()
 * Sets up the form to add a match as a content type for challenging
 * 	a specified team
 * @param $node the team to challenge
 * @return unknown_type
 */
function direct_match_form( $node )
{

	$date = '2011-12-31';
	$format = 'Y-m-d H:i';

	global $user;
	
	dpm( 'Hola' );
		
	module_load_include( 'php', 'team', 'db_functions' );
	module_load_include( 'php', 'base_datos_externa', 'db_functions' );


  //Esta función recibe sus argumentos de la barra de dirección,
  //el segundo si es que exite corresponde al nid_Equipo del equipo al que se está retando.
  $error = FALSE;

  $visitor_team = arg( 1 );
  
  //Checamos que exista una temporada activa, en caso de que no haya mostramos un mensaje al usuario indicando que tiene que haber una temporada activa

  if( is_null( temporada_activa( ) ) ){ 
    drupal_set_message('No puedes crear partidos si no hay temporadas activas.', 'error');
    $error = TRUE;
  }
  
  //Revisa que la modalidad esté activa en esta temporada
  $id_Modalidad_Juego_Temporada = get_modalidad_juego_temporada( $modalidad, $temporada_activa->id_Temporada );

  
  //para la primera vez que se crea un match, 
  //si no tiene temporada asignada, le asigna la temporada activa
  if(isset($node->temporada)){
    $default_value = $node->temporada;
  }else{
    $default_value = $temporada_activa->id_Temporada;
  }
  
  //Revisa que el jugador sea capitán de un equipo inscrito en la modalidad durante la temporada activa

  $nid_Equipo = is_capitan( $user->uid, $Modalidad_Juego_Temporada->id_Modalidad_Juego_Temporada );
	
	
  if ( $nid_Equipo == NULL ) {
     drupal_set_message('No perteneces a ningún equipo o no eres el capitán de tu equipo. Sólo los capitanes pueden crear partidas.', 'error');
     $error = TRUE;
		 drupal_goto( 'taxonomy/term/'.$id_Modalidad_Juego );
	}


  while( $Seasons = db_fetch_array( $Seasons_result_set ) )
  {
    $Seasons_list[ $Seasons[ 'id_Temporada' ] ] = $Seasons[ 'Nombre' ];
  } 
  
  $Teams = get_equipos( $id_Modalidad_Juego_Temporada  );
    
  $form[ 'Defining_Challenge' ][ 'Date_One' ] = array
  (
    '#type' => 'date_select', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
    '#title' => 'Posible fecha 1',
    '#default_value' => date( 'Y-m-d\TH:i' ), 
    '#date_format' => $format,
    '#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
    '#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
    '#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
    '#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
  );
  
  $form[ 'Defining_Challenge' ][ 'Date_Two' ] = array
  (
    '#type' => 'date_select', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
    '#title' => 'Posible fecha 2',
    '#default_value' => date( 'Y-m-d\TH:i' ), 
    '#date_format' => $format,
    '#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
    '#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
    '#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
    '#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
  );


  $form[ 'Defining_Challenge' ][ 'Date_Three' ] = array
  (
    '#type' => 'date_select', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
    '#title' => 'Posible fecha 3',
    '#default_value' => date( 'Y-m-d\TH:i' ), 
    '#date_format' => $format,
    '#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
    '#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
    '#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
    '#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
  );


  
  $form['Defining_Challenge']['Message'] = array
  (
    '#type' => 'textarea',
    '#title' => t('Mensaje de desafío'),
    '#default_value' => $node->body,
    '#required' => FALSE,
    '#description' => t('Use this to enter some pre-match comments for the game, or post a match report after the game.'),
    '#weight' => -5,
  );
  
  
  $form['Defining_Challenge']['filter'] = filter_form( $node->format );
  
	$form[ 'Defining_Challenge' ][ 'submit' ] = array
	(

		'#type' => 'submit',
		'#value' => t( 'Crear' ),
	);
	
  $form[ 'Defining_Challenge' ][ 'id_Modalidad_Juego_Temporada' ] = array
	(
		'#type' => 'hidden',
		'#value' => $id_Modalidad_Juego_Temporada,	
	);
	
  return $form;
}





/**DONE
 * Implementation of hook_form()
 * Sets up the form to add a match as a content type
 * @param unknown_type $node
 * @return unknown_type
 */
function indirect_match_form( $node )
{
	global $user;
	
	
	$date = '2011-12-31';
	$format = 'Y-m-d H:i';
	
	module_load_include( 'php', 'team', 'db_functions' );
	module_load_include( 'php', 'base_datos_externa', 'db_functions' );
	
  //Esta función recibe sus argumentos de la barra de dirección,
  //el primer argumento numérico corresponde al taxonomy id indicándonos la modalidad a la que pertenece este match
  $error = FALSE;
  
  //Checamos que exista una temporada activa, en caso de que no haya mostramos un mensaje al usuario indicando que tiene que haber una temporada activa
  if( is_null( $Temporada_Activa = temporada_activa( ) ) ){ 
    drupal_set_message( 'No puedes crear partidos si no hay temporadas activas.', 'error' );
    $error = TRUE;
  }
	
	//Obtiene la modalidad de jugo a través del tid y la temporada activa
  $Modalidad_Juego_Temporada = get_modalidad_juego_temporada_user( $user );	//$tid_Modalidad_Juego, $Temporada_Activa->id_Temporada );
	
	
	//Obtenemos la modalidad de equipo
	db_set_active( 'eSM' );
		$Jugador = db_fetch_object( db_query( 'SELECT { * } FROM { Jugador } AS { j } WHERE { j.id_Modalidad_Juego_Temporada = %d }', $Modalidad_Juego_Temporada->id_Modalidad_Juego_Temporada ) );
	db_set_active( 'default' );


	

  //para la primera vez que se crea un match, 
  //si no tiene temporada asignada, le asigna la temporada activa
  if( isset( $node->temporada ) ){
    $default_value = $node->temporada;
  }else{
    $default_value = $Temporada_Activa->id_Temporada;
  }
  
  //Revisa que el jugador sea capitán de un equipo inscrito en la modalidad durante la temporada activa
  $nid_Equipo = is_capitan( $user->uid, $Jugador->id_Modalidad_Juego_Temporada );
	
	
	//Obtenemos la modalidad de juego a través de $user

	$Modalidad_Juego = get_modalidad_juego_user( $user );
	
	
  if ( $nid_Equipo == NULL ) {
     drupal_set_message('No perteneces a ningún equipo o no eres el capitán de tu equipo. Sólo los capitanes pueden crear partidas.', 'error');
     $error = TRUE;
		 drupal_goto( 'taxonomy/term/'.$Modalidad_Juego->tid );
  }



  /*while( $Seasons = db_fetch_array( $Seasons_result_set ) )
  {
    $Seasons_list[ $Seasons[ 'id_Temporada' ] ] = $Seasons[ 'Nombre' ];
  } 
  
  $Teams = get_equipos( $id_Modalidad_Juego_Temporada  );*/
  
    
  $form[ 'Defining_Challenge' ][ 'Date_One' ] = array
  (
    '#type' => 'date_select', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
    '#title' => 'Posible fecha 1',
    '#default_value' => date( 'Y-m-d\TH:i' ), 
    '#date_format' => $format,
    '#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
    '#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
    '#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
    '#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
  );
  
  $form[ 'Defining_Challenge' ][ 'Date_Two' ] = array
  (
    '#type' => 'date_select', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
    '#title' => 'Posible fecha 2',
    '#default_value' => date( 'Y-m-d\TH:i' ), 
    '#date_format' => $format,
    '#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
    '#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
    '#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
    '#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
  );


  $form[ 'Defining_Challenge' ][ 'Date_Three' ] = array
  (
    '#type' => 'date_select', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
    '#title' => 'Posible fecha 3',
    '#default_value' => date( 'Y-m-d\TH:i' ), 
    '#date_format' => $format,
    '#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
    '#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
    '#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
    '#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
  );

	
  $form['Defining_Challenge']['Message'] = array
  (
    '#type' => 'textarea',
    '#title' => t('Mensaje de desafío'),
    '#required' => FALSE,
    '#description' => t('Use this to enter some pre-match comments for the game, or post a match report after the game.'),
    '#weight' => -5,
  );
  
  
  //$form['Defining_Challenge']['filter'] = filter_form( $node->format );
  
	$form[ 'Defining_Challenge' ][ 'submit' ] = array
	(

		'#type' => 'submit',
		'#value' => t( 'Crear' ),
	);
	
  $form[ 'Defining_Challenge' ][ 'id_Modalidad_Juego_Temporada' ] = array
	(
		'#type' => 'hidden',
		'#value' => $Jugador->id_Modalidad_Juego_Temporada,
	);
	
  return $form;
}
