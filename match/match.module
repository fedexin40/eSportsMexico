<?php
// Define los estados del desafío
    define( 'CREADO', 0 );
    define( 'PROGRAMADO', 1 );
    define( 'CANCELADO', 2 );
    define( 'COMPLETADO', 3 );
    define( 'CONFLICTO', 4 );
    
//Defnie los tipos de reto que puede haber
  define ('DESAFIO', 0);
  define ('IS_TORNEO', 1);
  
//Defnie los estados de reporte de resultados
  define ('INCOMPLETO', 0);
  define ('VICTORIA', 1);
  define ('DERROTA', 2);
  define ('PROTESTA', 3);
	
/**	DONE
 * Implementation of hook_node_info()
 * Declare the content type match
 * 
 */ 
function match_node_info() {
    return array
    (
        'match' => array
        (
            'name' => t('Desafio'),
            'module' => 'match',
            'description' => t("Un partido entre dos equipos inscritos en el ranking."),
        )
    );
}
/**	DONE
* Implementation of hook_perm()
* Outlines permissions for this module.
* @return array - An array of valid permissions for the match module
*/
function match_perm( ){
    return array( 'administer matches', 'create match', 'edit own match', 'delete own match', 'enter results');
}//end function match_perm()

/** DONE
 * Implementation of hook_access()
 */
function match_access($op, $node, $account){
    //users who can administer matches can do anything.
    if ( user_access('adminster matches', $account ) )
        return TRUE;
    
    if ($op == 'create') {
        // Only users with permission to do so may create this node type.
        return user_access('create match', $account);
    }
    
    if ($op == 'update') {
        if (user_access('edit own match', $account) && ($account->uid == $node->uid)) {
            return TRUE;
        }
    }
    
    if ($op == 'delete') {
        if(user_access('delete own match', $account) && ($account -> uid == $node ->uid)) {
            return TRUE;
        }
    }
    
    if ($op == 'view') {
        if(user_access('access content', $account)) {
            return TRUE;
        }
    }
    return FALSE;
}
	
	
	
/**
 *	Implememtation of hook_form( )
 *	Sets up the form to submit matches
 *	Permite tomar algunos argumentos de la barra de dirección para
 *	definir los partidos dentro de un torneo, o desafío específico
 *	@param
 *	  arg(3) = id_Modalidad_Juego_Temporada
 *	  arg(4) = nid_Equipo_Visitante
 *	  
 */
function match_form( &$node, $form_state ) {
  $format = 'Y-m-d H:i';
  global $user;
  
   
  if($node->Fecha_Inicio != '')
    $start_hour = format_date($node->Fecha_Inicio, 'small', $format);
  else
    $start_hour = format_date(time(), 'small', $format);
    
  if (isset($node->Estado) && ($node->Estado != CREADO)) {
    drupal_set_message(t('No se pueden editar las opciones de este partido.'), 'error');
  }
  else {
    if (!isset($node->id_Modalidad_Juego_Temporada) && (arg(3) == 0)) 
      drupal_set_message(t('No es la forma correcta de crear un partido.'), 'error');
    else {
      if (!isset($node->id_Modalidad_Juego_Temporada) && (arg(3) != 0))
          $node->id_Modalidad_Juego_Temporada = arg(3);
    
      if (!isset($node->Estado)) {
        $node->Estado = CREADO;
      }
      
      $query = get_teams($node->id_Modalidad_Juego_Temporada);   //Obtenemos la lista de equipos
      while ($team = db_fetch_object($query)) {
        $team = node_load(array('nid' => $team->nid_Equipo));
        $teams[$team->nid] =  $team->title;
      }
      
      if (!is_array($teams)) {
          drupal_set_message(t('La modalidad indicada todavia no tiene ningun equipo registrado.'), 'error');
      }
      else {
          $form['id_Modalidad_Juego_Temporada'] = array(
            '#type' => 'hidden',
            '#value' => $node->id_Modalidad_Juego_Temporada,
          );
        
          $form['Numero_Rondas'] = array(
            '#type' => 'select',
            '#title' => t('Numero de Rondas por Partido'),
            '#required' => TRUE,
            '#options' => array (
                            1 => '1',
                            2 => '2',
                            3 => '3',
                            4 => '4',
                            5 => '5',
                                 ),
            '#weight' => -9,
            '#default_value' => $node->Numero_Rondas,
          );
            
          $Equipo_Local = is_capitan($user->uid, $node->id_Modalidad_Juego_Temporada);
          
          if (is_null($Equipo_Local)) {
              drupal_set_message(t('Solo los capitanes de equipo pueden crear desafios.'), 'error');
          }
          else {
              $node->home_team = $Equipo_Local->nid;
              
              // We need to define form elements for the node's title and body.
              $form['home_team'] = array(
                '#type' => 'select',
                '#title' => t('Home Team'),
                '#required' => TRUE,
                '#options' => $teams,
                '#weight' => -8,
                '#default_value' => $node->home_team,
                '#disabled' => TRUE,
              );
                  
              $form['away_team'] = array(
                '#type' => 'select',
                '#title' => t('Away Team'),
                '#required' => TRUE,
                '#options' => $teams,
                '#weight' => -7,
              );
              
              if (!is_null(arg(4)))
                  $node->away_team = arg(4);
                  
              if (!is_null ($node->nid_Equipo_Visitante))
                  $node->away_team = $node->nid_Equipo_Visitante;
                  
              if (!is_null($node->away_team)) {
                  $form['away_team']['#default_value'] = $node->away_team;
                  $form['away_team']['#disabled'] = TRUE;
              }
              
              $form[ 'Fecha' ] = array (
                '#type' => 'date_select', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
                '#title' => 'Fecha y Hora de Inicio del Match',
                '#default_value' => $start_hour, 
                '#date_format' => $format,
                '#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
                '#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
                '#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
                '#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
              );
              
              $form['Estado'] = array(
                '#type' => 'hidden',
                '#value' => $node->Estado,
              );
              $form['Tipo'] = array(
                '#type' => 'hidden',
                '#value' => $node->Tipo,
              );
              
              $form['body_filter']['body'] = array(
                '#type' => 'textarea',
                '#title' => t('Match Notes'),
                '#default_value' => $node->body,
                '#required' => FALSE,
                '#description' => t('Use this to enter some pre-match comments for the game, or post a match report after the game.'),
                '#weight' => -5,
              );
              $form['body_filter']['filter'] = filter_form($node->format);
            
              return $form;
          }
      }
    }
  }
}
/*
 * Implementation of hook_load()
 * Esta función obtiene la información adicional almancenada en la base de datos de eSM
 * y la agrega al objeto de tipo nodo para su reproducción o manejo
 */
function match_load( $node ) {
  db_set_active('eSM');
	$reto = db_fetch_object(db_query( 'SELECT { * } FROM { Reto } AS { r } INNER JOIN { Inicio_Reto } AS { ir } ON { r.nid_Reto = ir.nid_Reto } WHERE { r.nid_Reto = %d }', $node->nid ) );
  db_set_active('default');

  $node->Estado = $reto->Estado;
  $node->id_Modalidad_Juego_Temporada = $reto->id_Modalidad_Juego_Temporada;
  $node->Fecha_Inicio = $reto->Fecha_Inicio;
  $node->Numero_Rondas = $reto->Numero_Rondas;
  $node->Tipo = $reto->Tipo;
  $node->nid_Equipo_Local = $reto->nid_Equipo_Local;
  $node->nid_Equipo_Visitante = $reto->nid_Equipo_Visitante;
  $node->Puntuacion_Inicial_Equipo_Local = $reto->Puntuacion_Inicial_Equipo_Local;
  $node->Puntuacion_Inicial_Equipo_Visitante = $reto->Puntuacion_Inicial_Equipo_Visitante;

  if ($reto->Estado == COMPLETADO) {    //Si el estado del reto es completado entonces carga los datos adicionales de la tabla de Final_Reto
    db_set_active('eSM');
      $resultado = db_fetch_object(db_query('SELECT * FROM {Fin_Reto} WHERE nid_Reto = %d', $node->nid));
    db_set_active('default');
    
    $node->ganador = $resultado->nid_Equipo_Ganador;
    $node->Puntuacion_Final_Equipo_Local = $resultado->Puntuacion_Final_Equipo_Local;
    $node->Puntuacion_Final_Equipo_Visitante = $resultado->Puntuacion_Final_Equipo_Visitante;
  }
  elseif ($reto->Estado == CONFLICTO) {
    db_set_active('eSM');
      $pruebas = db_fetch_object(db_query('SELECT * FROM {Prueba} WHERE nid_Reto = %d', $node->nid));
    db_set_active('default');
    
    $node->Prueba_Local = $pruebas->Prueba_Jugador_Local;
    $node->Prueba_Visitante = $pruebas->Prueba_Jugador_Visitante;
  }
  
  //load additional match data 
  module_invoke_all('match_load', $node);

  return $node;
}

/**	DONE
 * Implementation of hook_validate
 * Validates the match type before submission to ensure that the setup is correct
 * @param Object $node
 * @param Array $form
 */
function match_validate($node, $form){
  
  //Revisa que el partido tenga una temporada válida
  if (!isset($node->id_Modalidad_Juego_Temporada))
    form_set_error($node->id_Modalidad_Juego_Temporada, t('No has seleccionado una temporada validad para el partido.'));
  
  //Check that a team is not playing itself
  if( $node->home_team == $node->away_team ) {
    form_set_error( $node->away_team, t('A team cannot play itself!'));
  }
  
  //Checa que exista un equipo al que se está retando
  if ($node->away_team == 0)
    form_set_error( $node->away_team, t('No se ha seleccionado uno de los equipos'));
    
  //Checa que los equipos tengan el mínimo de jugadores necesarios para la modalidad
  $modalidad = get_modalidad($node->id_Modalidad_Juego_Temporada);
  $local = node_load(array('nid' => $node->home_team));
  $visitante = node_load(array('nid' => $node->away_team));
  if ($local->Numero_Integrantes < $modalidad->Minimo_Jugadores)
    form_set_error( $node->home_team, t('El equipo '. $local->title .' no tiene el minimo de jugadores necesarios.'));
  if ($visitante->Numero_Integrantes < $modalidad->Minimo_Jugadores)
    form_set_error( $node->away_team, t('El equipo '. $visitante->title .' no tiene el minimo de jugadores necesarios.'));
    
  //Revisa que los desafíos estén programados con un mínimo de 10min de anticipació y un máximo de 15 días
  $fecha_incio = strtotime($node->Fecha);     //Obtiene la fecha de inicio en formato timestamp
  
  if ($fecha_incio < (time() + 10*60) || $fecha_incio > (time() + 15*24*60*60))
    form_set_error($node->Fecha, t('La fecha de un desafio no se puede programar con menos de 10 minutos de anticipacion ni con más de 15 días de anticipacion.'));
  
  //Revisa que los equipos no tengan desafíos programados 60 minutos antes o después del inicio de este desafío
  db_set_active('eSM');
    $partidos_local = db_result(db_query('SELECT COUNT(*) FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ie ON r.nid_Reto = ie.nid_Reto WHERE
                               (nid_Equipo_Local = %d OR nid_Equipo_Visitante = %d)
                               AND (Fecha_Inicio > %d AND Fecha_Inicio < %d)
                               AND (Estado = %d)',
                               $node->home_team, $node->home_team, ($fecha_incio - 60*60), ($fecha_incio + 60*60), PROGRAMADO));
    $partidos_visitante = db_result(db_query('SELECT COUNT(*) FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ie ON r.nid_Reto = ie.nid_Reto WHERE
                                   (nid_Equipo_Local = %d OR nid_Equipo_Visitante = %d)
                                   AND (Fecha_Inicio > %d AND Fecha_Inicio < %d)
                                   AND (Estado = %d)',
                                   $node->away_team, $node->away_team, ($fecha_incio - 60*60), ($fecha_incio + 60*60), PROGRAMADO));
  db_set_active('default');
  
  if ($partidos_local > 0) {
    form_set_error($node->home_Team, t('El equipo '. $local->title .' tiene un desafio programado que entra en conflicto con este desafio.'));
  }
  if ($partidos_visitante > 0) {
    form_set_error($node->away_team, t('El equipo '. $visitante->title .' tiene un desafio programado que entra en conflicto con este desafio.'));
  }
  
  //Revisa que los equipos no tengan 3 desafíos en estado de conflicto
  db_set_active('eSM');
    $conflictos_local = db_result(db_query('SELECT COUNT(*) FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ir ON r.nid_Reto = ir.nid_Reto WHERE
                                 (nid_Equipo_Local = %d OR nid_Equipo_Visitante = %d) AND Estado = %d',
                                 $node->home_team, $node->home_team, CONFLICTO));
    $conflictos_visitante = db_result(db_query('SELECT COUNT(*) FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ir ON r.nid_Reto = ir.nid_Reto WHERE
                                     (nid_Equipo_Local = %d OR nid_Equipo_Visitante = %d) AND Estado = %d',
                                     $node->away_team, $node->away_team, CONFLICTO));
  db_set_active('default');
  
  if ($conflictos_local >= 3) {
    form_set_error($node->home_team, t('El equipo '. $local->title .' ha acumulado demasiados desafios en conflicto y no puede aceptar mas desafios.'));
  }
  if ($conflictos_visitante >= 3) {
    form_set_error($node->away_team, t('El equipo '. $visitante->title .' ha acumulado demasiados desafios en conflicto y no puede aceptar mas desafios.'));
  }
  
  //Revisa que los equipos no estén bloqueados por la liga
  $local = node_load(array('nid' => $node->home_team));
  if ($local->estado == BLOQUEADO)
    form_set_error($node->home_team, t('El equipo '. $local->title .' esta bloqueado y no puede aceptar mas desafios.'));
  $visitante = node_load(array('nid' => $node->away_team));
  if ($visitante->estado == BLOQUEADO)
    form_set_error($node->away_team, t('El equipo '. $visitante->title .' esta bloqueado y no puede aceptar mas desafios.'));
  
  //TODO: No se pueden disputar desafíos entre jugadores o equipos de diferentes divisiones (excepto durante el periodo de inicio de una temporada).
}
/**	
 * Implementation of hook_submit
 * Alters the title of the node before submission - otherwise it would be blank
 * @param Object $node
 */
function match_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL){
  if($op == 'presave' && $node->type == 'match'){
  //get the title. query the database to get the title of the teams.    
    $team = db_fetch_array(db_query("SELECT title FROM {node} WHERE nid = %d;", $node->home_team));
    $home_team = $team['title'];
    $team = db_fetch_array(db_query("SELECT title FROM {node} WHERE nid = %d;", $node ->away_team));
    $away_team = $team['title'];
    
    $search = array('[home_team]', '[away_team]');
    $replace = array($home_team, $away_team);

    $title = str_replace($search, $replace, '[home_team] vs [away_team]');
    
    $node->title = $title;
  }
}
/** DONE
 * Implementation of hook_insert()
 */
function match_insert($node){
  $fecha_inicio = strtotime($node->Fecha);
  //add the extra details to database
  db_set_active( 'eSM' );
    db_query( "INSERT INTO { Reto } ( nid_Reto, id_Modalidad_Juego_Temporada, Numero_Rondas, Fecha_Inicio, Tipo, Estado )
             VALUES (%d, %d, %d, %d, %d, %d )",
            $node->nid, $node->id_Modalidad_Juego_Temporada, $node->Numero_Rondas, $fecha_inicio, $node->Tipo, $node->Estado);
  
    $puntuacion_local = db_fetch_object(db_query('SELECT Puntuacion FROM {Puntuacion} WHERE nid_Equipo = %d', $node->home_team));
    $puntuacion_visitante = db_fetch_object(db_query('SELECT Puntuacion FROM {Puntuacion} WHERE nid_Equipo = %d', $node->away_team));
    
    db_query('INSERT INTO {Inicio_Reto} (nid_Reto, nid_Equipo_Local, nid_Equipo_Visitante, Puntuacion_Inicial_Equipo_Local, Puntuacion_Inicial_Equipo_Visitante)
             VALUES (%d, %d, %d, %d, %d)',
             $node->nid, $node->home_team, $node->away_team, $puntuacion_local->Puntuacion, $puntuacion_visitante->Puntuacion);
  
  db_set_active( 'default' );
  
  //TODO: use this hook
  module_invoke_all( 'match_insert', $node );
  
  //Asigna un conjunto de reglas para el match
  _match_asignar_reglas($node->nid, $node->Numero_Rondas);
  
  //Esta parte de la función notifica a los capitanes que les corresponde del desafío que se ha creado
  
  //Primero obtenemos los datos de los capitanes de los equipos  
    $home_team = node_load(array('nid' => $node->home_team));
    $away_team = node_load(array('nid' => $node->away_team));
    
    $home_capitan = user_load(array('uid' => $home_team->uid));
    $away_capitan = user_load(array('uid' => $away_team->uid));
        
  switch ($node->Estado) {
    case CREADO:        //Notifica al capitán del equipo visitante que el capitán del equipo local ha lanzado un reto contra él
        rules_invoke_event('desafio_lanzado', $home_capitan, $away_capitan, $node);
        
        break;
    case PROGRAMADO:    //Notifica a los capitanes de los dos equipos que se ha programado un partido entre ellos.
        $userB = user_load(array('uid' => 1));
        
        rules_invoke_event('partido_programado', $home_capitan, $userB);
        rules_invoke_event('partido_programado', $away_capitan, $userB);
        break;
  }
}

/**	DONE
 * Implementation of hook_update()
 * @param Object $node
 */
function match_update($node){
  //update the extra details to database
    $fecha_inicio = strtotime($node->Fecha);
  db_set_active( 'eSM' );
    db_query( "UPDATE { Reto } SET Numero_Rondas = %d, Fecha_Inicio = %d, Tipo = %d, Estado = %d
             WHERE nid_Reto = %d",
            $node->Numero_Rondas, $fecha_inicio, $node->Tipo, $node->Estado, $node->nid);
  db_set_active( 'default' );
  
  //TODO: use this hook
  module_invoke_all( 'match_insert', $node );
  
  //Esta parte de la función notifica a los capitanes que les corresponde del desafío que se ha creado
  
  //Primero obtenemos los datos de los capitanes de los equipos  
    $home_team = node_load(array('nid' => $node->home_team));
    $away_team = node_load(array('nid' => $node->away_team));
    
    $home_capitan = user_load(array('uid' => $home_team->uid));
    $away_capitan = user_load(array('uid' => $away_team->uid));
    
    rules_invoke_event('desafio_actualizado', $home_capitan, $away_capitan, $node);
    
  //call event_manager hook for an updated game
  module_invoke_all( 'match_update', $node );
}

/**	DONE
 *	Implementation of hook_delete()
 * @param Object $node
 */
function match_delete($node){
  //delete the extra details
	
  db_set_active( 'eSM' );
    $Reto = db_fetch_object( db_query( "SELECT * FROM { Reto } AS { r } WHERE { r.nid_Reto } = %d ", $node->nid ) );
  db_set_active( 'default' );
  
  if ($Reto->Tipo == IS_TORNEO) {
    watchdog('error', t('Se ha intentado borrar un desafio de un torneo.')); 
  }
  else {
    //Si es un reto completado actualizamos la tabla para restaurar los puntos como si el reto no hubiera existido.
    if( $Reto->Estado == 3 ) {
      //TODO: Actualizar el ránking del jugador haciendo la resta algebraica de puntos en su Puntuacion
      
    }
    
    db_set_active( 'eSM' );
      db_query("DELETE FROM { Reto } WHERE nid_Reto = %d", $node->nid );
      db_query('DELETE FROM {Inicio_Reto} WHERE nid_Reto = %d', $node->nid);
      db_query('DELETE FROM {Fin_Reto} WHERE nid_Reto = %d', $node->nid);
    db_set_active( 'default' );
  }
  
  module_invoke_all( 'match_delete', $node );
}

/**	DONE
 * Implementation of hook_view()
 * @param $node
 * @param $teaser
 * @param $page
 * @return unknown_type
 */
function match_view($node, $teaser = FALSE, $page = FALSE){
  $content = theme('match_content', $node);

  $node->content[] = array(
    '#value' => $content, 
    '#weight' => '0',
  );

  return $node;
}
/**	DONE
 * Implementation of hook_menu()
 * Sets up the admin menu system for the matches.
 */
function match_menu(){
  $items['node/%node/aceptar'] = array(
    'title' => t('Aceptar Desafio'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_aceptar'),
    'access callback' => 'match_aceptar_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
    'file' => 'inc/match_aceptar.inc',
  );
  $items['node/%node/reportar'] = array(
    'title' => 'Result',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_report'),
    'access callback' => 'match_report_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
    'file' => 'inc/match_reportar.inc',
  );
  $items['node/%node/pruebas'] = array(
    'title' => 'Envio de Pruebas',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_pruebas'),
    'access callback' => 'match_report_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
    'file' => 'inc/match_pruebas.inc',
  );
  $items[ 'node/%node/desafios' ] = array (
    'title' => t('Desafios'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'team_lista_desafios' ),
    'access callback' => 'match_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/match_lista_desafios.inc',
  );
  $items[ 'node/%node/desafios/programados' ] = array (
    'title' => t('Desafios Programados'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'team_lista_desafios' ),
    'access callback' => 'match_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'inc/match_lista_desafios.inc',
    'weight' => 0,
  );
  $items[ 'node/%node/desafios/confirmar' ] = array (
    'title' => t('Desafios por Confirmar'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'team_lista_desafios' ),
    'access callback' => 'match_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/match_lista_desafios.inc',
    'weight' => 1,
  );
  $items[ 'node/%node/desafios/conflicto' ] = array (
    'title' => t('Desafios en Conflicto'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'team_lista_desafios' ),
    'access callback' => 'match_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/match_lista_desafios.inc',
    'weight' => 2,
  );
  $items[ 'node/%node/desafios/terminados' ] = array (
    'title' => t('Desafios Terminados'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'team_lista_desafios' ),
    'access callback' => 'match_ver_lista_desafios_access',
    'access arguments' => array( 1 ),
    'type' => MENU_LOCAL_TASK,
    'file' => 'inc/match_lista_desafios.inc',
    'weight' => 3,
  );  
	/*
  $items[ 'taxonomy/term/%/challenges' ] = array
	(
    'title' => 'Tablero de desafíos',
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'challenges_binnacle' ),
    //'access callback' => 'matches_viewing',
    'access arguments' => array( 'matches_viewing' ),
    'type' => MENU_LOCAL_TASK,
    //'file' => 'inc/match.admin.inc',
  );
	
  $items[ 'taxonomy/term/%/challenges/create' ] = array
	(
    'title' => 'Crear un desafío',
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'indirect_match_form' ),
    'access callback' => 'match_report_access',
    'type' => MENU_LOCAL_TASK,
    //'file' => 'inc/match.admin.inc',
  );*/
	
  return $items;
}

/**	DONE
 *	Access argument for the node report score page -
 *	just return node access for users who have permission to report the match score
 */
function match_report_access( $node ) {  
  global $user;
  
  //Revisa que el nodo sea del tipo match, en caso contrario devuelve falso
  if ($node->type != 'match')
    return FALSE;
  
  //users who can administer matches can do anything.
  if ( user_access( 'administer matches'))
    return TRUE;
  
  //Revisa que el usuario sea el capitán/creador de alguno de los dos equipos en el match
  if (team_user_is_team_capitan($user->uid, $node->nid_Equipo_Local) || team_user_is_team_capitan($user->uid, $node->nid_Equipo_Visitante))
    return TRUE;
  else
    return FALSE;
}
/**	DONE
 *	Access argument for the node report score page -
 *	just return node access for users who have permission to report the match score
 */
function match_aceptar_access( $node ) {
  global $user;

  //Revisa que el nodo sea del tipo match, en caso contrario devuelve falso
  if ($node->type != 'match')
    return FALSE;

  
  //Revisa que el usuario sea el capitán/creador del equipo retado
  if ( team_user_is_team_capitan($user->uid, $node->nid_Equipo_Visitante))
    return TRUE;
  else
    return FALSE;
}

/**
 * Función para verificar quien tiene acceso a la lista de desafios
 */
function match_ver_lista_desafios_access($node) {
  global $user;
  
  //Revisa que el nodo sea del tipo match, en caso contrario devuelve falso
  if ($node->type != 'team')
    return FALSE;
  
  return user_access('access content', $user);
}
/** DONE
 * Implementation of hook_form_FORM_ID_alter
 * This sets the default team correctly on the dropdown boxes on the generated form
 */
function match_form_match_node_form_alter( &$form, $form_state ) {
    
}

/**	DONE
 * Implementation of hook_theme()
 * 
 */
function match_theme($existing, $type, $theme, $path) {
  return array(
    'match_content' => array(
      'file' => 'node_content.inc',
      'path' => drupal_get_path('module', 'match') .'/theme',
      'arguments' => array('node'),
    ),
    'match_fivestar_static' => array(
      'file' => 'fivestar.inc',
      'path' => drupal_get_path('module', 'match') .'/theme',
      'arguments' => array('rating' => NULL, 'stars' => 5),
    ),
    'match_lista_desafios' => array(
      'file' => 'lista_desafios.inc',
      'path' => drupal_get_path('module', 'match') .'/theme',
      'arguments' => array('form' => NULL),
    ),
  );
}
/**
 * Implementation of hook_rules_event_info().
 * Usado para notificar a los capitanes de los desafíos lanzados, aceptados, cancelados y programados
 * @ingroup rules
 */
function match_rules_event_info() {
  return array(
    'desafio_lanzado' => array(
      'label' => t('UserA ha desafiado al equipo de userB'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, que ha desafiado al equipo de userB.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, que ha sido desafiado por el equipo de UserA.')),
        'match' => array('type' => 'node', 'label' => t('Detalles del desafio.')),
      ),
    ),
    'desafio_actualizado' => array(
      'label' => t('UserA ha los detalles del desafio al equipo de userB'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, que ha desafiado al equipo de userB.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, que ha sido desafiado por el equipo de UserA.')),
        'match' => array('type' => 'node', 'label' => t('Detalles del desafio.')),
      ),
    ),
    'desafio_aceptado' => array(
      'label' => t('UserA ha aceptado el desafio del equipo de userB'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, ha aceptado el desafio del equipo de userB.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, ha solicitado enfrentar el equipo de UserA.')),
      ),
    ),
    'desafio_cancelado' => array(
      'label' => t('UserA ha rechazado el desafio del equipo de userB'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, ha rechazado el desafio del equipo de userB.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, ha solicitado enfrentar el equipo de UserA.')),
      ),
    ),
    'partido_programado' => array(
      'label' => t('UserA tiene un partido programado'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, capitan del equipo al que se le ha programado un partido por un torneo.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, usuario del sistema que notifica a UserA del partido programado.')),
      ),
    ),
  );
}
/**	NOT DONE
 * Implementation of hook_views_api()
 */
function match_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'match') .'/views',
  );
}

/**	DONE
 * Implementation of hook_block()
 * @return unknown_type
 */
function match_block($op = 'list', $delta = 0, $edit = array()){
  switch($op){
    case 'list':
      $block = array();
      $block[0]['info'] = t('View upcoming games');
      $block[1]['info'] = t('View latest results');
      $block[2]['info'] = t('Desafiar');
      $block[3]['info'] = t('Calificacion del equipo');
      break;
    case 'view':
      $block_content = '';
      switch($delta){
        case 0:
          //upcoming games
          $block['subject'] = t('Upcoming Matches');
          $to_show = db_query("SELECT {node}.nid, {node}.title, {signup}.min_pp, {match}.home_team, {match}.away_team FROM {node}, {match}, {signup} WHERE {node}.nid = {match}.nid AND {match}.relation_id = {signup}.nid AND {match}.is_result = 0 ORDER BY {match}.match_time ASC LIMIT %d;", 3);
          $block['content'] = theme('match_block', $to_show);
          break;
        case 1:
          //latest results
          $block['subject'] = t('Latest Results');
          $to_show = db_query("SELECT {node}.nid, {node}.title, {signup}.min_pp, {match}.home_team, {match}.away_team FROM {node}, {match}, {signup} WHERE {node}.nid = {match}.nid AND {match}.relation_id = {signup}.nid AND {match}.is_result = 1 ORDER BY {match}.match_time DESC LIMIT %d;", 3);
          $block['content'] = theme('match_block', $to_show);
          break;
        case 2:
          //Desafiar
          if ($content = _match_prepare_desafiar_link()) {
            $block['subject'] = 'Desafiar';
            $block['content'] = l('Desafiar', $content);
          }
          break;
        case 3:
          //Desplegar la reputación del equipo
          if (is_array($content = _match_display_reputation())) {
            $block['subject'] = t('Reputacion');
            //$block['content'] = t('Fivestar');
            $block['content'] = theme('match_fivestar_static', $content['vote']['percent']['average'], 5, 'vote');
          }
          break;
      }
      
      break;
    case 'save':
      
      break;
    case 'configure':
      
      break;
  }
  return $block;
}


/**	ALMOST DONE
 *	Función que se encargará de mostrar la bitácora de desafíos creados para las modalidades
 *	y temporadas activas al momento
 */
function challenges_binnacle( )
{
	
	module_load_include( 'php', 'base_datos_externa', 'db_functions' );
	
	$date = '2011-12-31';
	$format = 'Y-m-d H:i';
	
	$tid_Modalidad_Juego = arg( 2 );
	$Temporada_Activa = temporada_activa(  );
	
	db_set_active( 'eSM' );
		$Challenges_result_set = db_query( 'SELECT { * } FROM { Reto } AS { r } INNER JOIN { Modalidad_Juego_Temporada } AS { mjt } ON { r.id_Modalidad_Juego_Temporada = mjt.id_Modalidad_Juego_Temporada } INNER JOIN { Temporada } AS { t } ON { mjt.id_Temporada = t.id_Temporada } INNER JOIN { Modalidad_Juego } AS { mj } ON { mjt.id_Modalidad_Juego = mj.id_Modalidad_Juego } WHERE { mj.tid = %d } AND { t.id_Temporada = %d } AND { r.Estado = %d }', $tid_Modalidad_Juego, $Temporada_Activa->id_Temporada, CREADO );
	db_set_active( 'default' );

	if ( $Challenges_result_set->num_rows )
	{
		
			/*$form[ 'Challenges_List' ] = array
			(
			
				'#type' => 'fieldset',
				'#title' => 'Lista de desafíos',
				'#collapsible' => 'FALSE',
				'#collapsed' => 'FALSE',
			 
			);*/		
		
		while( $Challenge = db_fetch_object( $Challenges_result_set ) )
		{
			
			$Fecha_Inicio = timestamp_to_string( $Challenge->Fecha_Inicio );
			$Fecha_Fin = timestamp_to_string( $Challenge->Fecha_Fin );
	
			
			$form[ 'Challenge_List' ][ $Challenge->nid_Reto ][ 'id_Reto' ] = array
			(
				'#type' => 'item',
				//'label' => t( 'Nombre' ),
				//'#disabled' => 'TRUE',
				//'size' => 17,
				//'maxlength' => 17,
				'#title' => t( 'Número de reto' ),
				//'#required' => TRUE,
				'#weight' => -8,
				'#value' => $Challenge->nid_Reto,
			);
			
			$form[ 'Challenge_List' ][ $Challenge->nid_Reto ][ 'Fecha_Inicio' ] = array (
				'#type' => 'date_text', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
				'#disabled' => 'TRUE',
				'#title' => 'Fecha de inicio',
				'#default_value' => $Fecha_Inicio,
				'#date_format' => $format,
				'#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
				'#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
				'#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
				'#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
				'#size' => 17,
				'#maxlength' => 17,
			);
	
	
			$form[ 'Challenge_List' ][ $Challenge->nid_Reto ][ 'Fecha_Fin' ] = array (
				'#type' => 'date_text', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
				'#disabled' => 'TRUE',
				'#title' => 'Fecha de inicio',
				'#default_value' => $Fecha_Fin,
				'#date_format' => $format,
				'#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
				'#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
				'#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
				'#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
				'#size' => 17,
				'#maxlength' => 17,
			);
	
			$form[ 'Challenge_List' ][ $Challenge->nid_Reto ][ 'Estado' ] = array (
				'#type' => 'item', 
				'#title' => 'Estado',
				'#value' => $Challenge->Estado,
			);
		
		
			$form[ 'Challenge_List' ][ $Challenge->nid_Reto ][ 'Aceptar' ] = array
			(
				
				'#type' => 'submit',
				'#value' => t('Aceptar desafío'),
				
			);
			
		}	
		
		$form[ 'tid_Modalidad_Juego' ] = array
		(		
			'#type' => 'hidden',
			'#value' => $tid_Modalidad_Juego,
		);
		
		$form[ 'id_Temporada_Activa' ] = array
		(		
			'#type' => 'hidden',
			'#value' => $Temporada_Activa,
		);

	}
	
	else
	{
		
		$form[ 'Message' ] = array
		(
			
			'#type' => 'item',
			'#value' => t( 'No hay desafíos disponibles para esta modalidad' ),
			
		);
		
	}
	
	return $form;
	
}



/**
 * Función para obtener las pruebas que han reportado para los partidos
 *
 * @param
 *  nid_Reto
 *
 * @return
 *  $pruebas[home_team] = 'link';
 *  $pruebas[away_team] = 'link';
 */
function match_get_pruebas($nid_Reto) {
    db_set_active('eSM');
        $pruebas = db_fetch_array(db_query('SELECT * FROM {Prueba} WHERE nid_Reto = %d', $nid_Reto));
    db_set_active('default');
    
    return $pruebas;
}
/**
 * Función para obtener la modalidad de juego a la que pertenece un reto
 *
 * @param
 *  nid_Reto
 *
 * @return
 *  $pruebas[home_team] = 'link';
 *  $pruebas[away_team] = 'link';
 */
function match_get_modalidad_juego($nid_Reto) {
    db_set_active('eSM');
        $result = db_fetch_array(db_query('SELECT {id_Modalidad_Juego } FROM {Modalidad_Juego_Temporada} AS mj INNER JOIN {Reto} AS r ON mj.id_Modalidad_Juego_Temporada = r.id_Modalidad_Juego_Temporada WHERE nid_Reto = %d', $nid_Reto));
    db_set_active('default');
    
    return $result['id_Modalidad_Juego'];
}
/**
 * Función para asignar las reglas de un partido
 *
 * @param
 *  $nid_Reto: El nid_Reto al cual se le tienen que asignar
 *  $numero_rondas: Cuantos conjuntos de reglas se deben asignar
 */
function _match_asignar_reglas ($nid_Reto, $numero_rondas) {
    $modalidad_juego = match_get_modalidad_juego($nid_Reto);
    
    //Obtiene todos los mapas y modalidades de juego de la modalidad de juego
    $mapas = mapas_get_mapas_modalidad($modalidad_juego);
    $modos = modos_get_modos_modalidad($modalidad_juego);
    
    //Nos aseguramos de tener el mínimo de mapas y modalidades para el número de rondas
    while (count($mapas) < $numero_rondas) {
      $mapas = array_merge($mapas, $mapas);
    }
    while (count($modos) < $numero_rondas) {
      $mapas = array_merge($modos, $modos);
    }
    //Mezcla los mapas y modos para escoger en órden aleatorio
    shuffle($mapas);
    shuffle($modos);
    
    for($i = 1; $i <= $numero_rondas; $i++) {
        //Obtien el primer elemento de cada uno de los arreglos de mapa y modo
        $mapa_regla = array_shift($mapas);
        $modo_regla = array_shift($modos);
        
        db_set_active('eSM');
            db_query('INSERT INTO {Regla} (nid_Reto, id_Mapa, id_Modo_Juego) VALUES (%d, %d, %d)', $nid_Reto, $mapa_regla, $modo_regla);
        db_set_active('default');
    }
}
/**
 * Función para obtener todas las reglas asignadas a un partido
 *
 * @param
 *  $nid_Reto: El nid_Reto al cual se le tienen que asignar
 *
 *  @return
 *   $reglas: Arreglo con todas las reglas asignadas al partido
 */
function _match_obtener_reglas ($nid_Reto) {
    //Obtiene todas las reglas asignadas al partido de la base de datos
    db_set_active('eSM');
        $result = db_query('SELECT * FROM {Regla} WHERE nid_Reto = %d', $nid_Reto);
    db_set_active('default');
    
    $i = 0;
    while ($regla = db_fetch_object($result)) {
        ++$i;
        $reglas[$i]['id_Mapa'] = $regla->id_Mapa;
        $reglas[$i]['id_Modo_Juego'] = $regla->id_Modo_Juego;
    }
    
    return $reglas;
}
/**
 * Función para obtener el resultado reportado por un equipo en un desafio
 *
 * @param
 *  nid_Reto
 *  nid_Equipo
 *
 * @return
 *  objeto con el resultado reportado por el equipo
 *  NULL en caso de que el equipo no haya reportado nada todaví
 */
function _match_get_team_resultado ($nid_Reto, $nid_Equipo) {
	db_set_active('eSM');
		$reporte = db_fetch_object(db_query('SELECT * FROM {Reporte_Reto} WHERE nid_Reto = %d AND nid_Equipo = %d', $nid_Reto, $nid_Equipo));
	db_set_active('default');
    
    return $reporte;
}
/**
 * Función para verificar el estado de un desafio
 *
 * @param
 *   nid_Reto
 */
function _match_check_match($nid_Reto) {
  $reto = node_load($nid_Reto);
  
  $reporte_equipo_local = _match_get_team_resultado($nid_Reto, $reto->nid_Equipo_Local);
  $reporte_equipo_visitante = _match_get_team_resultado($nid_Reto, $reto->nid_Equipo_Visitante);
  
  //Verifica si los dos equipos han reportardo su resultado
  if(is_object($reporte_equipo_local) && is_object($reporte_equipo_visitante)) {
    if (($reporte_equipo_local->Resultado == VICTORIA) && ($reporte_equipo_visitante->Resultado == DERROTA)) {
      //Resultado coherente indicando que ganó el equipo local
      $nid_Ganador = $reto->nid_Equipo_Local;
    }
    elseif (($reporte_equipo_local->Resultado == DERROTA) && ($reporte_equipo_visitante->Resultado == VICTORIA)) {
      //Resultado coherente indicando que ganó el equipo visitante
      $nid_Ganador = $reto->nid_Equipo_Visitante;
    }
    
    //Si no hay un ganador definido, entonces el desafío debe ir al estado de conflicto
    if ($nid_Ganador == 0) {
      _match_update_match($nid_Reto, CONFLICTO);
    }
    else {
      _match_end_match($nid_Reto, $nid_Ganador);
    }
  }
}

/**
 * Función para actualizar el estado de un desafio
 *
 * @param
 *   nid_Reto
 *   Estado
 */
function _match_update_match($nid_Reto, $estado) {
    db_set_active('eSM');
      db_query('UPDATE {Reto} SET Estado = %d WHERE nid_Reto = %d', $estado, $nid_Reto);
    db_set_active('default');
    
    //TODO: Ejectuar acciones o enviar notificaciones de acuerdo al estado del match
}
/**
 * Función para poner un desafio en estado COMPLETADO
 * calcula las nuevas puntuaciones de los equipos
 * guarda el ganador del match en la tabla Fin_Reto
 * llama a las funciones para actualizar el ránking o los brackets
 *
 * @param
 *   nid_Reto
 *   nid_Ganador
 */
function _match_end_match($nid_Reto, $nid_Ganador) {
	$reto = node_load($nid_Reto);
    
    if ($reto->Tipo == IS_TORNEO) {
      //Para los desafios de torneos, las puntuaciones finales son iguales a las puntuaciones iniciales
      db_set_active('eSM');
        db_query('INSERT INTO {Fin_Reto}
                 (nid_Reto, Puntuacion_Final_Equipo_Local, Puntuacion_Final_Equipo_Visitante, nid_Ganador)
                 VALUES (%d, %d, %d, %d)',
                 $nid_Reto, $reto->Puntuacion_Inicial_Equipo_Local, $reto->Puntuacion_Inicial_Equipo_Visitante, $nid_Ganador);
      db_set_active('default');
      
      //Obtiene el torneo del que forma parte el desafio
      db_set_active('eSM');
        $Torneo = db_fetch_object(db_query('SELECT * FROM {Retos_Torneos} WHERE nid_Reto = %d', $nid_Reto));
      db_set_active('default');
      
      //Actualiza los brackets del torneo
      _torneo_update_bracket($Torneo->nid_Torneo, $nid_Ganador);
    }
    else {
      //Calcula las puntuaciones finales para los dos equipos en base a la tabla definida en el ránking
      _ranking_calcula_desafio($reto->nid_Equipo_Local, $reto->nid_Equipo_Visitante, $nid_Ganador, $reto->Puntuacion_Inicial_Equipo_Local, $reto->Puntuacion_Inicial_Equipo_Visitante);

      //Obtiene las puntuaciones finales de cada equipo
      $puntuacion_local = _ranking_get_team_puntuacion($reto->nid_Equipo_Local);
      $puntuacion_visitante = _ranking_get_team_puntuacion($reto->nid_Equipo_Visitante);
      
      //Guarda los datos en Fin_Reto
      db_set_active('eSM');
        db_query('INSERT INTO {Fin_Reto}
                 (nid_Reto, Puntuacion_Final_Equipo_Local, Puntuacion_Final_Equipo_Visitante, nid_Equipo_Ganador)
                 VALUES (%d, %d, %d, %d)',
                 $nid_Reto, $puntuacion_local, $puntuacion_visitante, $nid_Ganador);
      db_set_active('default');
    }
    
    //Actualiza el estado del reto a COMPLETADO
    _match_update_match($nid_Reto, COMPLETADO);
}
/**
 * Función para crear un reporte de mala conducta para un equipo
 *
 * @param
 *  nid_Reto
 *  nid_Equipo
 *  Reporte:  0 => 'Seleccione una',
              1 => 'Insultos o amenazas',
              2 => 'Comentarios ofensivos',
              3 => 'Juego sucio o trampas',
 */
function _match_crear_reporte_mala_conducta ($nid_Reto, $nid_Equipo, $conducta) {
  db_set_active('eSM');
    db_query('INSERT INTO {Reto_Conducta} (nid_Reto, nid_Equipo, Reporte, Estado) VALUES (%d, %d, %d, %d)', $nid_Reto, $nid_Equipo, $conducta, 0);
  db_set_active('default');
  
  //TODO: Mandar un mensaje al coordinador deportivo para que revise el estado del reporte.
}
/**
 * Función para preparar el link para que los equipos se puedan desafiar entre ellos
 */
function _match_prepare_desafiar_link() {  
    //Carga el nodo
    if (arg(0) == 'node' && is_numeric(arg(1)))
        $node = node_load(arg(1));
        
    //Revisa que el nodo pertenezca a un equipo
    if ($node->type == 'team') {
        //Prepara el link para desafiar a este equipo
        $link = 'node/add/match/'. $node->id_Modalidad_Juego_Temporada .'/'. $node->nid;
    }
    
    return $link;
}
/**
 * Función para preparar el despliegue de la reputación del equipo
 */
function _match_display_reputation() {
    //Carga el nodo
    if (arg(0) == 'node' && is_numeric(arg(1)))
        $node = node_load(arg(1));
        
    //Revisa que el nodo pertenezca a un equipo
    if ($node->type == 'team') {
        //Prepara el link para desafiar a este equipo
        $vote = _votingapi_get_standard_results('team', $node->nid);
    }
    
    return $vote;
}
/**
 * Función para obtener una lista de los matches que coinciden con un criterio
 *
 * @param
 *  nid_Equipo
 *  $criterio
 *
 * @return
 *  mysql object
 */
function _match_get_match_list ($nid_Equipo, $criterio) {
  db_set_active('eSM');
    $query = db_query('SELECT * FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ir ON r.nid_Reto = ir.nid_Reto
                      WHERE (ir.nid_Equipo_Local = %d OR ir.nid_Equipo_Visitante = %d) AND r.Estado = %d',
                      $nid_Equipo, $nid_Equipo, $criterio);
  db_set_active('default');
  
  return $query;
}
/**
 * Función para obtener el resultado de un partido
 * @param
 *  nid_Reto
 *
 * @return
 *  Objeto con el resulatdo de un partido
 */
function _match_get_resultado ($nid_Reto) {
  db_set_active('eSM');
    $resultado = db_fetch_object(db_query('SELECT * FROM {Fin_Reto} WHERE nid_Reto = %d', $nid_Reto));
  db_set_active('default');
  
  return $resultado;
}