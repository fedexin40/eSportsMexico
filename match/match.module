<?php
// Define los estados del desafío
    define( 'CREADO', 0 );
    define( 'PROGRAMADO', 1 );
    define( 'CANCELADO', 2 );
    define( 'COMPLETADO', 3 );
    define( 'CONFLICTO', 4 );
    
//Defnie los tipos de reto que puede haber
  define ('DESAFIO', 0);
  define ('IS_TORNEO', 1);
	
/**	DONE
 * Implementation of hook_node_info()
 * Declare the content type match
 * 
 */ 
function match_node_info() {
    return array
    (
        'match' => array
        (
            'name' => t('Desafio'),
            'module' => 'match',
            'description' => t("Un partido entre dos equipos inscritos en el ranking."),
        )
    );
}
/**	DONE
* Implementation of hook_perm()
* Outlines permissions for this module.
* @return array - An array of valid permissions for the match module
*/
function match_perm( ){
    return array( 'administer matches', 'create match', 'edit own match', 'delete own match', 'enter own match results');
}//end function match_perm()

/** DONE
 * Implementation of hook_access()
 */
function match_access($op, $node, $account){
    //users who can administer matches can do anything.
    if ( user_access('adminster matches', $account ) )
        return TRUE;
    
    if ($op == 'create') {
        // Only users with permission to do so may create this node type.
        return user_access('create match', $account);
    }
    
    if ($op == 'update') {
        if (user_access('edit own match', $account) && ($account->uid == $node->uid)) {
            return TRUE;
        }
    }
    
    if ($op == 'delete') {
        if(user_access('delete own match', $account) && ($account -> uid == $node ->uid)) {
            return TRUE;
        }
    }
    
    if ($op == 'view') {
        if(user_access('access content', $account)) {
            return TRUE;
        }
    }
    return FALSE;
}
	
	
	
/**
 *	Implememtation of hook_form( )
 *	Sets up the form to submit matches
 *	Permite tomar algunos argumentos de la barra de dirección para
 *	definir los partidos dentro de un torneo, o desafío específico
 *	@param
 *	  arg(3) = id_Modalidad_Juego_Temporada
 *	  arg(4) = nid_Equipo_Visitante
 *	  
 */
function match_form( &$node, $form_state ) {
  $format = 'Y-m-d H:i';
  global $user;
   
  if($node->Fecha_Inicio != '')
    $start_hour = format_date($node->Fecha_Inicio, 'small', $format);
  else
    $start_hour = format_date(time(), 'small', $format);
    
  if ($node->Estado != CREADO) {
    drupal_set_message(t('No se pueden editar las opciones de este partido.'), 'error');
  }
  else {
    if (!isset($node->id_Modalidad_Juego_Temporada) && (arg(3) == 0)) 
      drupal_set_message(t('No es la forma correcta de crear un partido.'), 'error');
    else {
      if (!isset($node->id_Modalidad_Juego_Temporada) && (arg(3) != 0))
          $node->id_Modalidad_Juego_Temporada = arg(3);
    
      if (!isset($node->Estado)) {
        $node->Estado = CREADO;
      }
      
      $query = get_teams($node->id_Modalidad_Juego_Temporada);   //Obtenemos la lista de equipos
      while ($team = db_fetch_object($query)) {
        $team = node_load(array('nid' => $team->nid_Equipo));
        $teams[$team->nid] =  $team->title;
      }
      
      if (!is_array($teams)) {
          drupal_set_message(t('La modalidad indicada todavia no tiene ningun equipo registrado.'), 'error');
      }
      else {
          $form['id_Modalidad_Juego_Temporada'] = array(
            '#type' => 'hidden',
            '#value' => $node->id_Modalidad_Juego_Temporada,
          );
        
          $form['Numero_Rondas'] = array(
            '#type' => 'select',
            '#title' => t('Numero de Rondas por Partido'),
            '#required' => TRUE,
            '#options' => array (
                            1 => '1',
                            2 => '2',
                            3 => '3',
                            4 => '4',
                            5 => '5',
                                 ),
            '#weight' => -9,
            '#default_value' => $node->Numero_Rondas,
          );
            
          $Equipo_Local = is_capitan($user->uid, $node->id_Modalidad_Juego_Temporada);
          
          if (is_null($Equipo_Local)) {
              drupal_set_message(t('Solo los capitanes de equipo pueden crear desafios.'), 'error');
          }
          else {
              $node->home_team = $Equipo_Local->nid;
              
              // We need to define form elements for the node's title and body.
              $form['home_team'] = array(
                '#type' => 'select',
                '#title' => t('Home Team'),
                '#required' => TRUE,
                '#options' => $teams,
                '#weight' => -8,
                '#default_value' => $node->home_team,
                '#disabled' => TRUE,
              );
                  
              $form['away_team'] = array(
                '#type' => 'select',
                '#title' => t('Away Team'),
                '#required' => TRUE,
                '#options' => $teams,
                '#weight' => -7,
              );
              
              if (!is_null(arg(4)))
                  $node->away_team = arg(4);
                  
              if (!is_null ($node->nid_Equipo_Visitante))
                  $node->away_team = $node->nid_Equipo_Visitante;
                  
              if (!is_null($node->away_team)) {
                  $form['away_team']['#default_value'] = $node->away_team;
                  $form['away_team']['#disabled'] = TRUE;
              }
              
              $form[ 'Fecha' ] = array (
                '#type' => 'date_select', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
                '#title' => 'Fecha y Hora de Inicio del Match',
                '#default_value' => $start_hour, 
                '#date_format' => $format,
                '#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
                '#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
                '#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
                '#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
              );
              
              $form['Estado'] = array(
                '#type' => 'hidden',
                '#value' => $node->Estado,
              );
              $form['Tipo'] = array(
                '#type' => 'hidden',
                '#value' => $node->Tipo,
              );
              
              $form['body_filter']['body'] = array(
                '#type' => 'textarea',
                '#title' => t('Match Notes'),
                '#default_value' => $node->body,
                '#required' => FALSE,
                '#description' => t('Use this to enter some pre-match comments for the game, or post a match report after the game.'),
                '#weight' => -5,
              );
              $form['body_filter']['filter'] = filter_form($node->format);
            
              return $form;
          }
      }
    }
  }
}
/*
 * Implementation of hook_load()
 * Esta función obtiene la información adicional almancenada en la base de datos de eSM
 * y la agrega al objeto de tipo nodo para su reproducción o manejo
 */
function match_load( $node ) {
	//Es necesario que los campos nid_Equipo_Local, nid_Equipo_Visitante, Puntuacion_Inicial_Equipo_Local, Puntuacion_Inicial_Equipo_Visitante
	//sean por defecto 0
  db_set_active('eSM');
	$reto = db_fetch_object(db_query( 'SELECT { * } FROM { Reto } AS { r } INNER JOIN { Inicio_Reto } AS { ir } ON { r.nid_Reto = ir.nid_Reto } WHERE { r.nid_Reto = %d }', $node->nid ) );
  db_set_active('default');

  $node->Estado = $reto->Estado;
  $node->id_Modalidad_Juego_Temporada = $reto->id_Modalidad_Juego_Temporada;
  $node->Fecha_Inicio = $reto->Fecha_Inicio;
  $node->Numero_Rondas = $reto->Numero_Rondas;
  $node->Tipo = $reto->Tipo;
  $node->nid_Equipo_Local = $reto->nid_Equipo_Local;
  $node->nid_Equipo_Visitante = $reto->nid_Equipo_Visitante;
  $node->Puntuacion__Inicial_Equipo_Local = $reto->Puntuacion_Inicial_Equipo_Local;
  $node->Puntuacion_Inicial_Equipo_Visitante = $reto->Puntuacion_Inicial_Equipo_Visitante;
  
  db_set_active('eSM');
    $reglas = db_query('SELECT * FROM {Regla} WHERE nid_Reto = %d', $node->nid);
  db_set_active('default');
  
  for ($i = 1; $i <= $reto->Numero_Rondas; $i++) {
    $rules[$i] = db_fetch_object($reglas);
  }
  $node->reglas = $rules;

  if ($reto->Estado == COMPLETADO) {    //Si el estado del reto es completado entonces carga los datos adicionales de la tabla de Final_Reto
    db_set_active('eSM');
      $resultado = db_fetch_object(db_query('SELECT * FROM {Fin_Reto} WHERE nid_Reto = %d', $node->nid));
    db_set_active('default');
    
    $node->ganador = $resultado->nid_Equipo_Ganador;
    $node->Puntuacion_Final_Equipo_Local = $resultado->Puntuacion_Final_Equipo_Local;
    $node->Puntuacion_Final_Equipo_Visitante = $resultado->Puntuacion_Final_Equipo_Visitante;
  }
  elseif ($reto->Estado == CONFLICTO) {
    db_set_active('eSM');
      $pruebas = db_fetch_object(db_query('SELECT * FROM {Prueba} WHERE nid_Reto = %d', $node->nid));
    db_set_active('default');
    
    $node->Prueba_Local = $pruebas->Prueba_Jugador_Local;
    $node->Prueba_Visitante = $pruebas->Prueba_Jugador_Visitante;
  }
  
  //load additional match data 
  module_invoke_all('match_load', $node);

  return $node;
}

/**	DONE
 * Implementation of hook_validate
 * Validates the match type before submission to ensure that the setup is correct
 * @param Object $node
 * @param Array $form
 */
function match_validate($node, $form){
  
  //Revisa que el partido tenga una temporada válida
  if (!isset($node->id_Modalidad_Juego_Temporada))
    form_set_error($node->id_Modalidad_Juego_Temporada, t('No has seleccionado una temporada validad para el partido.'));
  
  //Check that a team is not playing itself
  if( $node->home_team == $node->away_team ) {
    form_set_error( $node->away_team, t('A team cannot play itself!'));
  }
  
  //Checa que exista un equipo al que se está retando
  if ($node->away_team == 0)
    form_set_error( $node->away_team, t('No se ha seleccionado uno de los equipos'));
    
  //Revisa que los desafíos estén programados con un mínimo de 10min de anticipació y un máximo de 15 días
  $fecha_incio = strtotime($node->Fecha);     //Obtiene la fecha de inicio en formato timestamp
  
  if ($fecha_incio < (time() + 10*60) || $fecha_incio > (time() + 15*24*60*60))
    form_set_error($node->Fecha, t('La fecha de un desafio no se puede programar con menos de 10 minutos de anticipacion ni con más de 15 días de anticipacion.'));
  
  //Revisa que los equipos no tengan desafíos programados 60 minutos antes o después del inicio de este desafío
  db_set_active('eSM');
    $partidos_local = db_result(db_query('SELECT COUNT(*) FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ie ON r.nid_Reto = ie.nid_Reto WHERE
                               (nid_Equipo_Local = %d OR nid_Equipo_Visitante = %d)
                               AND (Fecha_Inicio > %d AND Fecha_Inicio < %d)
                               AND (Estado = %d)',
                               $node->home_team, $node->home_team, ($fecha_incio - 60*60), ($fecha_incio + 60*60), PROGRAMADO));
    $partidos_visitante = db_result(db_query('SELECT COUNT(*) FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ie ON r.nid_Reto = ie.nid_Reto WHERE
                                   (nid_Equipo_Local = %d OR nid_Equipo_Visitante = %d)
                                   AND (Fecha_Inicio > %d AND Fecha_Inicio < %d)
                                   AND (Estado = %d)',
                                   $node->away_team, $node->away_team, ($fecha_incio - 60*60), ($fecha_incio + 60*60), PROGRAMADO));
  db_set_active('default');
  
  if ($partidos_local > 0) {
    $local = node_load(array('nid' => $node->home_team));
    form_set_error($node->home_Team, t('El equipo '. $local->title .' tiene un desafio programado que entra en conflicto con este desafio.'));
  }
  if ($partidos_visitante > 0) {
    $visitante = node_load(array('nid' => $node->away_team));
    form_set_error($node->away_team, t('El equipo '. $visitante->title .' tiene un desafio programado que entra en conflicto con este desafio.'));
  }
  
  //Revisa que los equipos no tengan 3 desafíos en estado de conflicto
  db_set_active('eSM');
    $conflictos_local = db_result(db_query('SELECT COUNT(*) FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ir ON r.nid_Reto = ir.nid_Reto WHERE
                                 (nid_Equipo_Local = %d OR nid_Equipo_Visitante = %d) AND Estado = %d',
                                 $node->home_team, $node->home_team, CONFLICTO));
    $conflictos_visitante = db_result(db_query('SELECT COUNT(*) FROM {Reto} AS r INNER JOIN {Inicio_Reto} AS ir ON r.nid_Reto = ir.nid_Reto WHERE
                                     (nid_Equipo_Local = %d OR nid_Equipo_Visitante = %d) AND Estado = %d',
                                     $node->away_team, $node->away_team, CONFLICTO));
  db_set_active('default');
  
  if ($conflictos_local >= 3) {
    $local = node_load(array('nid' => $node->home_team));
    form_set_error($node->home_team, t('El equipo '. $local->title .' ha acumulado demasiados desafios en conflicto y no puede aceptar mas desafios.'));
  }
  if ($conflictos_visitante >= 3) {
    $visitante = node_load(array('nid' => $node->away_team));
    form_set_error($node->away_team, t('El equipo '. $visitante->title .' ha acumulado demasiados desafios en conflicto y no puede aceptar mas desafios.'));
  }
  
  //Revisa que los equipos no estén bloqueados por la liga
  $local = node_load(array('nid' => $node->home_team));
  if ($local->estado == BLOQUEADO)
    form_set_error($node->home_team, t('El equipo '. $local->title .' esta bloqueado y no puede aceptar mas desafios.'));
  $visitante = node_load(array('nid' => $node->away_team));
  if ($visitante->estado == BLOQUEADO)
    form_set_error($node->away_team, t('El equipo '. $visitante->title .' esta bloqueado y no puede aceptar mas desafios.'));
  
  //TODO: No se pueden disputar desafíos entre jugadores o equipos de diferentes divisiones (excepto durante el periodo de inicio de una temporada).
}
/**	
 * Implementation of hook_submit
 * Alters the title of the node before submission - otherwise it would be blank
 * @param Object $node
 */
function match_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL){
  if($op == 'presave' && $node->type == 'match'){
  //get the title. query the database to get the title of the teams.    
    $team = db_fetch_array(db_query("SELECT title FROM {node} WHERE nid = %d;", $node->home_team));
    $home_team = $team['title'];
    $team = db_fetch_array(db_query("SELECT title FROM {node} WHERE nid = %d;", $node ->away_team));
    $away_team = $team['title'];
    
    $search = array('[home_team]', '[away_team]');
    $replace = array($home_team, $away_team);

    $title = str_replace($search, $replace, '[home_team] vs [away_team]');
    
    $node->title = $title;
  }
}
/** DONE
 * Implementation of hook_insert()
 */
function match_insert($node){
  $fecha_inicio = strtotime($node->Fecha);
  //add the extra details to database
  db_set_active( 'eSM' );
    db_query( "INSERT INTO { Reto } ( nid_Reto, id_Modalidad_Juego_Temporada, Numero_Rondas, Fecha_Inicio, Tipo, Estado )
             VALUES (%d, %d, %d, %d, %d, %d )",
            $node->nid, $node->id_Modalidad_Juego_Temporada, $node->Numero_Rondas, $fecha_inicio, $node->Tipo, $node->Estado);
  
    $puntuacion_local = db_fetch_object(db_query('SELECT Puntuacion FROM {Puntuacion} WHERE nid_Equipo = %d', $node->home_team));
    $puntuacion_visitante = db_fetch_object(db_query('SELECT Puntuacion FROM {Puntuacion} WHERE nid_Equipo = %d', $node->away_team));
    
    db_query('INSERT INTO {Inicio_Reto} (nid_Reto, nid_Equipo_Local, nid_Equipo_Visitante, Puntuacion_Inicial_Equipo_Local, Puntuacion_Inicial_Equipo_Visitante)
             VALUES (%d, %d, %d, %d, %d)',
             $node->nid, $node->home_team, $node->away_team, $puntuacion_local->Puntuacion, $puntuacion_visitante->Puntuacion);
  
  db_set_active( 'default' );
  
  //TODO: use this hook
  module_invoke_all( 'match_insert', $node );
  
  //Esta parte de la función notifica a los capitanes que les corresponde del desafío que se ha creado
  
  //Primero obtenemos los datos de los capitanes de los equipos  
    $home_team = node_load(array('nid' => $node->home_team));
    $away_team = node_load(array('nid' => $node->away_team));
    
    $home_capitan = user_load(array('uid' => $home_team->uid));
    $away_capitan = user_load(array('uid' => $away_team->uid));
        
  switch ($node->Estado) {
    case CREADO:        //Notifica al capitán del equipo visitante que el capitán del equipo local ha lanzado un reto contra él
        rules_invoke_event('desafio_lanzado', $home_capitan, $away_capitan, $node);
        
        break;
    case PROGRAMADO:    //Notifica a los capitanes de los dos equipos que se ha programado un partido entre ellos.
        $userB = user_load(array('uid' => 1));
        
        rules_invoke_event('partido_programado', $home_capitan, $userB);
        rules_invoke_event('partido_programado', $away_capitan, $userB);
        break;
  }
}

/**	DONE
 * Implementation of hook_update()
 * @param Object $node
 */
function match_update($node){
  //update the extra details to database
    $fecha_inicio = strtotime($node->Fecha);
  db_set_active( 'eSM' );
    db_query( "UPDATE { Reto } SET Numero_Rondas = %d, Fecha_Inicio = %d, Tipo = %d, Estado = %d)
             WHERE nid_Reto = %d",
            $node->Numero_Rondas, $fecha_inicio, $node->Tipo, $node->Estado, $node->nid);
  db_set_active( 'default' );
  
  //TODO: use this hook
  module_invoke_all( 'match_insert', $node );
  
  //Esta parte de la función notifica a los capitanes que les corresponde del desafío que se ha creado
  
  //Primero obtenemos los datos de los capitanes de los equipos  
    $home_team = node_load(array('nid' => $node->home_team));
    $away_team = node_load(array('nid' => $node->away_team));
    
    $home_capitan = user_load(array('uid' => $home_team->uid));
    $away_capitan = user_load(array('uid' => $away_team->uid));
    
    rules_invoke_event('desafio_actualizado', $home_capitan, $away_capitan, $node);
    
  //call event_manager hook for an updated game
  module_invoke_all( 'match_update', $node );
}

/**	DONE
 *	Implementation of hook_delete()
 * @param Object $node
 */
function match_delete($node){
  //delete the extra details
	
  db_set_active( 'eSM' );
    $Reto = db_fetch_object( db_query( "SELECT * FROM { Reto } AS { r } WHERE { r.nid_Reto } = %d ", $node->nid ) );
  db_set_active( 'default' );
  
  if ($Reto->Tipo == IS_TORNEO) {
    watchdog('error', t('Se ha intentado borrar un desafio de un torneo.')); 
  }
  else {
    //Si es un reto completado actualizamos la tabla para restaurar los puntos como si el reto no hubiera existido.
    if( $Reto->Estado == 3 ) {
      //TODO: Actualizar el ránking del jugador haciendo la resta algebraica de puntos en su Puntuacion
      
    }
    
    db_set_active( 'eSM' );
      db_query("DELETE FROM { Reto } WHERE nid_Reto = %d", $node->nid );
      db_query('DELETE FROM {Inicio_Reto} WHERE nid_Reto = %d', $node->nid);
      db_query('DELETE FROM {Fin_Reto} WHERE nid_Reto = %d', $node->nid);
    db_set_active( 'default' );
  }
  
  module_invoke_all( 'match_delete', $node );
}

/**	DONE
 * Implementation of hook_view()
 * @param $node
 * @param $teaser
 * @param $page
 * @return unknown_type
 */
function match_view($node, $teaser = FALSE, $page = FALSE){
  $content = theme('match_content', $node);

  $node->content[] = array(
    '#value' => $content, 
    '#weight' => '0',
  );

  return $node;
}
/**	NOT DONE
 * Implementation of hook_menu()
 * Sets up the admin menu system for the matches.
 */
function match_menu(){
  $items['matchadmin'] = array(
    'title' => 'Match Admin',
    'description' => t('View and enter pending results'),
    'page callback' => 'match_admin',
    'access arguments' => array('administer matches'),
    'file' => 'inc/match.admin.inc',
  );
  $items['admin/settings/matches'] = array(
    'title' => 'Match Settings',
    'description' => t('Set various options for match entry'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_settings'),
    'access arguments' => array('administer matches'),
    'file' => 'inc/match.admin.inc',
  );
  $items['node/%node/edit/match'] = array(
    'title' => 'Match',
    'access callback' => 'match_edit_access',
    'access arguments' => array(1),
    'weight' => -10,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['node/%node/edit/score'] = array(
    'title' => 'Result',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_score_edit'),
    'access callback' => 'match_report_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
    'file' => 'inc/match.admin.inc',
  );
	
  $items[ 'taxonomy/term/%/challenges' ] = array
	(
    'title' => 'Tablero de desafíos',
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'challenges_binnacle' ),
    //'access callback' => 'matches_viewing',
    'access arguments' => array( 'matches_viewing' ),
    'type' => MENU_LOCAL_TASK,
    //'file' => 'inc/match.admin.inc',
  );
	
  $items[ 'taxonomy/term/%/challenges/create' ] = array
	(
    'title' => 'Crear un desafío',
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'indirect_match_form' ),
    'access callback' => 'match_report_access',
    'type' => MENU_LOCAL_TASK,
    //'file' => 'inc/match.admin.inc',
  );
	
	$items[ 'node/%node/desafiar/' ] = array
	(
    'title' => 'Desafiar',
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'direct_match_form' ),
    //'access callback' => 'match_report_access',
    'access arguments' => array( 'create match' ),
    'type' => MENU_LOCAL_TASK,
    //'file' => 'inc/match.admin.inc',
  );
	
	
	$items[ 'node/%node/desafios/' ] = array
	(
    'title' => 'Desafíos',
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'team_challenges_binnacle' ),
    //'access callback' => 'match_report_access',
    'access arguments' => array( 'create match' ),
    'type' => MENU_LOCAL_TASK,
    //'file' => 'inc/match.admin.inc',
  );
	
  return $items;
}


/**	NOT DONE
 *
 * Access argument for the node edit page - just return node access for updating the node
 */
function match_edit_access( $node )
{
  return node_access( 'update', $node );
}

/**	NOT DONE
 *	Access argument for the node report score page -
 *	just return node access for users who have permission to report the match score
 */
function match_report_access( ) {
  global $user;
  
  //users who can administer matches can do anything.
  if ( user_access( 'administer matches') )
    return TRUE;
  
  //Revisa que el usuario sea el capitán/creador de alguno de los dos equipos en el match
  //$home_team = node_load( $node->home_team );
  //$visitor_team = node_load( $node->visitor_team );
  
  if ( $user->uid == $home_team->uid || $user->uid == $visitor_team->uid)
      return TRUE;
    
  return FALSE;
}

/** DONE
 * Implementation of hook_form_FORM_ID_alter
 * This sets the default team correctly on the dropdown boxes on the generated form
 */
function match_form_match_node_form_alter( &$form, $form_state ) {
    
}

/**	DONE
 * Implementation of hook_theme()
 * 
 */
function match_theme($existing, $type, $theme, $path) {
  return array(
    'match_content' => array(
      'file' => 'node_content.inc',
      'path' => drupal_get_path('module', 'match') .'/theme',
      'arguments' => array('node'),
    ),
  );
}
/**
 * Implementation of hook_rules_event_info().
 * Usado para notificar a los capitanes de los desafíos lanzados, aceptados, cancelados y programados
 * @ingroup rules
 */
function match_rules_event_info() {
  return array(
    'desafio_lanzado' => array(
      'label' => t('UserA ha desafiado al equipo de userB'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, que ha desafiado al equipo de userB.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, que ha sido desafiado por el equipo de UserA.')),
        'match' => array('type' => 'node', 'label' => t('Detalles del desafio.')),
      ),
    ),
    'desafio_actualizado' => array(
      'label' => t('UserA ha los detalles del desafio al equipo de userB'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, que ha desafiado al equipo de userB.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, que ha sido desafiado por el equipo de UserA.')),
        'match' => array('type' => 'node', 'label' => t('Detalles del desafio.')),
      ),
    ),
    'desafio_aceptado' => array(
      'label' => t('UserA ha aceptado el desafio del equipo de userB'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, ha aceptado el desafio del equipo de userB.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, ha solicitado enfrentar el equipo de UserA.')),
      ),
    ),
    'desafio_cancelado' => array(
      'label' => t('UserA ha rechazado el desafio del equipo de userB'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, ha rechazado el desafio del equipo de userB.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, ha solicitado enfrentar el equipo de UserA.')),
      ),
    ),
    'partido_programado' => array(
      'label' => t('UserA tiene un partido programado'),
      'module' => 'Match',
      'arguments' => array(
        'userA' => array('type' => 'user', 'label' => t('UserA, capitan del equipo al que se le ha programado un partido por un torneo.')),
        'userB' => array('type' => 'user', 'label' => t('UserB, usuario del sistema que notifica a UserA del partido programado.')),
      ),
    ),
  );
}
/**	NOT DONE
 * Implementation of hook_views_api()
 */
function match_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'match') .'/views',
  );
}

/**	NOT DONE
 * Implementation of hook_block()
 * @return unknown_type
 */
function match_block($op = 'list', $delta = 0, $edit = array()){
  switch($op){
    case 'list':
      $blockArray = array();
      $blockArray[0]['info'] = t('View upcoming games');
      $blockArray[1]['info'] = t('View latest results');
      return $blockArray;
      break;
    case 'view':
      $block_content = '';
      switch($delta){
        case 0:
          //upcoming games
          $block['subject'] = t('Upcoming Matches');
          $to_show = db_query("SELECT {node}.nid, {node}.title, {signup}.min_pp, {match}.home_team, {match}.away_team FROM {node}, {match}, {signup} WHERE {node}.nid = {match}.nid AND {match}.relation_id = {signup}.nid AND {match}.is_result = 0 ORDER BY {match}.match_time ASC LIMIT %d;", 3);
          break;
        case 1:
          //latest results
          $block['subject'] = t('Latest Results');
          $to_show = db_query("SELECT {node}.nid, {node}.title, {signup}.min_pp, {match}.home_team, {match}.away_team FROM {node}, {match}, {signup} WHERE {node}.nid = {match}.nid AND {match}.relation_id = {signup}.nid AND {match}.is_result = 1 ORDER BY {match}.match_time DESC LIMIT %d;", 3);
          break;
      }
      $block['content'] = theme('match_block', $to_show);
      return $block;
      break;
    case 'save':
      
      break;
    case 'configure':
      
      break;
  }
}


/**	ALMOST DONE
 *	Función que se encargará de mostrar la bitácora de desafíos creados para las modalidades
 *	y temporadas activas al momento
 */
function challenges_binnacle( )
{
	
	module_load_include( 'php', 'base_datos_externa', 'db_functions' );
	
	$date = '2011-12-31';
	$format = 'Y-m-d H:i';
	
	$tid_Modalidad_Juego = arg( 2 );
	$Temporada_Activa = temporada_activa(  );
	
	db_set_active( 'eSM' );
		$Challenges_result_set = db_query( 'SELECT { * } FROM { Reto } AS { r } INNER JOIN { Modalidad_Juego_Temporada } AS { mjt } ON { r.id_Modalidad_Juego_Temporada = mjt.id_Modalidad_Juego_Temporada } INNER JOIN { Temporada } AS { t } ON { mjt.id_Temporada = t.id_Temporada } INNER JOIN { Modalidad_Juego } AS { mj } ON { mjt.id_Modalidad_Juego = mj.id_Modalidad_Juego } WHERE { mj.tid = %d } AND { t.id_Temporada = %d } AND { r.Estado = %d }', $tid_Modalidad_Juego, $Temporada_Activa->id_Temporada, CREADO );
	db_set_active( 'default' );

	if ( $Challenges_result_set->num_rows )
	{
		
			/*$form[ 'Challenges_List' ] = array
			(
			
				'#type' => 'fieldset',
				'#title' => 'Lista de desafíos',
				'#collapsible' => 'FALSE',
				'#collapsed' => 'FALSE',
			 
			);*/		
		
		while( $Challenge = db_fetch_object( $Challenges_result_set ) )
		{
			
			$Fecha_Inicio = timestamp_to_string( $Challenge->Fecha_Inicio );
			$Fecha_Fin = timestamp_to_string( $Challenge->Fecha_Fin );
	
			
			$form[ 'Challenge_List' ][ $Challenge->nid_Reto ][ 'id_Reto' ] = array
			(
				'#type' => 'item',
				//'label' => t( 'Nombre' ),
				//'#disabled' => 'TRUE',
				//'size' => 17,
				//'maxlength' => 17,
				'#title' => t( 'Número de reto' ),
				//'#required' => TRUE,
				'#weight' => -8,
				'#value' => $Challenge->nid_Reto,
			);
			
			$form[ 'Challenge_List' ][ $Challenge->nid_Reto ][ 'Fecha_Inicio' ] = array (
				'#type' => 'date_text', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
				'#disabled' => 'TRUE',
				'#title' => 'Fecha de inicio',
				'#default_value' => $Fecha_Inicio,
				'#date_format' => $format,
				'#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
				'#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
				'#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
				'#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
				'#size' => 17,
				'#maxlength' => 17,
			);
	
	
			$form[ 'Challenge_List' ][ $Challenge->nid_Reto ][ 'Fecha_Fin' ] = array (
				'#type' => 'date_text', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
				'#disabled' => 'TRUE',
				'#title' => 'Fecha de inicio',
				'#default_value' => $Fecha_Fin,
				'#date_format' => $format,
				'#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
				'#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
				'#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
				'#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
				'#size' => 17,
				'#maxlength' => 17,
			);
	
			$form[ 'Challenge_List' ][ $Challenge->nid_Reto ][ 'Estado' ] = array (
				'#type' => 'item', 
				'#title' => 'Estado',
				'#value' => $Challenge->Estado,
			);
		
		
			$form[ 'Challenge_List' ][ $Challenge->nid_Reto ][ 'Aceptar' ] = array
			(
				
				'#type' => 'submit',
				'#value' => t('Aceptar desafío'),
				
			);
			
		}	
		
		$form[ 'tid_Modalidad_Juego' ] = array
		(		
			'#type' => 'hidden',
			'#value' => $tid_Modalidad_Juego,
		);
		
		$form[ 'id_Temporada_Activa' ] = array
		(		
			'#type' => 'hidden',
			'#value' => $Temporada_Activa,
		);

	}
	
	else
	{
		
		$form[ 'Message' ] = array
		(
			
			'#type' => 'item',
			'#value' => t( 'No hay desafíos disponibles para esta modalidad' ),
			
		);
		
	}
	
	return $form;
	
}



/**	ALMOST DONE
 *	Función que se encargará de mostrar la bitácora de desafíos creados para las modalidades
 *	y temporadas activas al momento
 */
function team_challenges_binnacle( )
{
	
	module_load_include( 'php', 'base_datos_externa', 'db_functions' );
	
	$date = '2011-12-31';
	$format = 'Y-m-d H:i';
	
	$tid_Modalidad_Juego = arg( 2 );
	$Temporada_Activa = temporada_activa(  );
	
	db_set_active( 'eSM' );
		$Challenges_result_set = db_query( 'SELECT { * } FROM { Reto } AS { r } INNER JOIN { Modalidad_Juego_Temporada } AS { mjt } ON { r.id_Modalidad_Juego_Temporada = mjt.id_Modalidad_Juego_Temporada } INNER JOIN { Temporada } AS { t } ON { mjt.id_Temporada = t.id_Temporada } INNER JOIN { Modalidad_Juego } AS { mj } ON { mjt.id_Modalidad_Juego = mj.id_Modalidad_Juego } WHERE { mj.tid = %d } AND { t.id_Temporada = %d } AND { r.Estado = %d }', $tid_Modalidad_Juego, $Temporada_Activa->id_Temporada, CREADO );
	db_set_active( 'default' );

	if ( $Challenges_result_set->num_rows )
	{

			/*$form[ 'Challenges_List' ] = array
			(
			
				'#type' => 'fieldset',
				'#title' => 'Lista de desafíos',
				'#collapsible' => 'FALSE',
				'#collapsed' => 'FALSE',
			 
			);*/		
	
		
		
		while( $Challenge = db_fetch_object( $Challenges_result_set ) )
		{
			


			
			$Fecha_Inicio = timestamp_to_string( $Challenge->Fecha_Inicio );
			$Fecha_Fin = timestamp_to_string( $Challenge->Fecha_Fin );
	
			
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'id_Reto' ] = array
			(
				'#type' => 'item',
				//'label' => t( 'Nombre' ),
				//'#disabled' => 'TRUE',
				//'size' => 17,
				//'maxlength' => 17,
				'#title' => t( 'Número de reto' ),
				//'#required' => TRUE,
				'#weight' => -8,
				'#value' => $Challenge->id_Reto,
			);
			
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'Fecha_Inicio' ] = array (
				'#type' => 'date_text', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
				'#disabled' => 'TRUE',
				'#title' => 'Fecha de inicio',
				'#default_value' => $Fecha_Inicio,
				'#date_format' => $format,
				'#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
				'#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
				'#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
				'#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
				'#size' => 17,
				'#maxlength' => 17,
			);
	
	
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'Fecha_Fin' ] = array (
				'#type' => 'date_text', // types 'date_text' and 'date_timezone' are also supported. See .inc file.
				'#disabled' => 'TRUE',
				'#title' => 'Fecha de inicio',
				'#default_value' => $Fecha_Fin,
				'#date_format' => $format,
				'#date_label_position' => 'within', // See other available attributes and what they do in date_api_elements.inc
				'#date_timezone' => 'America/Chicago', // Optional, if your date has a timezone other than the site timezone.
				'#date_increment' => 15, // Optional, used by the date_select and date_popup elements to increment minutes and seconds.
				'#date_year_range' => '0:+2', // Optional, used to set the year range (back 3 years and forward 3 years is the default).
				'#size' => 17,
				'#maxlength' => 17,
			);
	
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'Estado' ] = array (
				'#type' => 'item', 
				'#title' => 'Estado',
				'#value' => $Challenge->Estado,
			);
		
		
			$form[ 'Challenge_List' ][ $Challenge->id_Reto ][ 'Aceptar' ] = array
			(
				
				'#type' => 'submit',
				'#value' => t('Aceptar desafío'),
				
			);
			
		}	
		
		$form[ 'tid_Modalidad_Juego' ] = array
		(		
			'#type' => 'hidden',
			'#value' => $tid_Modalidad_Juego,
		);
		
		
		
		$form[ 'id_Temporada_Activa' ] = array
		(		
			'#type' => 'hidden',
			'#value' => $Temporada_Activa,
		);

	}
	
	else
	{
		
		$form[ 'Message' ] = array
		(
			
			'#type' => 'item',
			'#value' => t( 'No hay desafíos disponibles para esta modalidad' ),
			
		);
		
	}
	
	
	return $form;
	
}